( () => {
    var Pi = Object.create;
    var Me = Object.defineProperty;
    var Ri = Object.getOwnPropertyDescriptor;
    var Li = Object.getOwnPropertyNames
      , ht = Object.getOwnPropertySymbols
      , Ii = Object.getPrototypeOf
      , ct = Object.prototype.hasOwnProperty
      , Di = Object.prototype.propertyIsEnumerable;
    var dt = (e, t, i) => t in e ? Me(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: i
    }) : e[t] = i
      , se = (e, t) => {
        for (var i in t || (t = {}))
            ct.call(t, i) && dt(e, i, t[i]);
        if (ht)
            for (var i of ht(t))
                Di.call(t, i) && dt(e, i, t[i]);
        return e
    }
    ;
    var P = (e, t) => () => (t || e((t = {
        exports: {}
    }).exports, t),
    t.exports);
    var Oi = (e, t, i, r) => {
        if (t && typeof t == "object" || typeof t == "function")
            for (let n of Li(t))
                !ct.call(e, n) && n !== i && Me(e, n, {
                    get: () => t[n],
                    enumerable: !(r = Ri(t, n)) || r.enumerable
                });
        return e
    }
    ;
    var ut = (e, t, i) => (i = e != null ? Pi(Ii(e)) : {},
    Oi(t || !e || !e.__esModule ? Me(i, "default", {
        value: e,
        enumerable: !0
    }) : i, e));
    var mt = P( (gt, Ae) => {
        (function(e, t) {
            "use strict";
            function i() {
                r.width = e.innerWidth,
                r.height = 5 * d.barThickness;
                var h = r.getContext("2d");
                h.shadowBlur = d.shadowBlur,
                h.shadowColor = d.shadowColor;
                var p, g = h.createLinearGradient(0, 0, r.width, 0);
                for (p in d.barColors)
                    g.addColorStop(p, d.barColors[p]);
                h.lineWidth = d.barThickness,
                h.beginPath(),
                h.moveTo(0, d.barThickness / 2),
                h.lineTo(Math.ceil(n * r.width), d.barThickness / 2),
                h.strokeStyle = g,
                h.stroke()
            }
            var r, n, s, o = null, a = null, l = null, d = {
                autoRun: !0,
                barThickness: 3,
                barColors: {
                    0: "rgba(26,  188, 156, .9)",
                    ".25": "rgba(52,  152, 219, .9)",
                    ".50": "rgba(241, 196, 15,  .9)",
                    ".75": "rgba(230, 126, 34,  .9)",
                    "1.0": "rgba(211, 84,  0,   .9)"
                },
                shadowBlur: 10,
                shadowColor: "rgba(0,   0,   0,   .6)",
                className: null
            }, f = {
                config: function(h) {
                    for (var p in h)
                        d.hasOwnProperty(p) && (d[p] = h[p])
                },
                show: function(h) {
                    var p, g;
                    s || (h ? l = l || setTimeout( () => f.show(), h) : (s = !0,
                    a !== null && e.cancelAnimationFrame(a),
                    r || ((g = (r = t.createElement("canvas")).style).position = "fixed",
                    g.top = g.left = g.right = g.margin = g.padding = 0,
                    g.zIndex = 100001,
                    g.display = "none",
                    d.className && r.classList.add(d.className),
                    t.body.appendChild(r),
                    p = "resize",
                    h = i,
                    (g = e).addEventListener ? g.addEventListener(p, h, !1) : g.attachEvent ? g.attachEvent("on" + p, h) : g["on" + p] = h),
                    r.style.opacity = 1,
                    r.style.display = "block",
                    f.progress(0),
                    d.autoRun && function y() {
                        o = e.requestAnimationFrame(y),
                        f.progress("+" + .05 * Math.pow(1 - Math.sqrt(n), 2))
                    }()))
                },
                progress: function(h) {
                    return h === void 0 || (typeof h == "string" && (h = (0 <= h.indexOf("+") || 0 <= h.indexOf("-") ? n : 0) + parseFloat(h)),
                    n = 1 < h ? 1 : h,
                    i()),
                    n
                },
                hide: function() {
                    clearTimeout(l),
                    l = null,
                    s && (s = !1,
                    o != null && (e.cancelAnimationFrame(o),
                    o = null),
                    function h() {
                        return 1 <= f.progress("+.1") && (r.style.opacity -= .05,
                        r.style.opacity <= .05) ? (r.style.display = "none",
                        void (a = null)) : void (a = e.requestAnimationFrame(h))
                    }())
                }
            };
            typeof Ae == "object" && typeof Ae.exports == "object" ? Ae.exports = f : typeof define == "function" && define.amd ? define(function() {
                return f
            }) : this.topbar = f
        }
        ).call(gt, window, document)
    }
    );
    var rt = P( (Xn, Xt) => {
        function Ir(e) {
            var t = typeof e;
            return e != null && (t == "object" || t == "function")
        }
        Xt.exports = Ir
    }
    );
    var Wt = P( (qn, qt) => {
        var Dr = typeof global == "object" && global && global.Object === Object && global;
        qt.exports = Dr
    }
    );
    var nt = P( (Wn, Kt) => {
        var Or = Wt()
          , Nr = typeof self == "object" && self && self.Object === Object && self
          , Hr = Or || Nr || Function("return this")();
        Kt.exports = Hr
    }
    );
    var Yt = P( (Kn, Gt) => {
        var jr = nt()
          , Mr = function() {
            return jr.Date.now()
        };
        Gt.exports = Mr
    }
    );
    var Zt = P( (Gn, Qt) => {
        var Ur = /\s/;
        function $r(e) {
            for (var t = e.length; t-- && Ur.test(e.charAt(t)); )
                ;
            return t
        }
        Qt.exports = $r
    }
    );
    var ti = P( (Yn, ei) => {
        var Fr = Zt()
          , Br = /^\s+/;
        function Jr(e) {
            return e && e.slice(0, Fr(e) + 1).replace(Br, "")
        }
        ei.exports = Jr
    }
    );
    var st = P( (Qn, ii) => {
        var zr = nt()
          , Vr = zr.Symbol;
        ii.exports = Vr
    }
    );
    var oi = P( (Zn, si) => {
        var ri = st()
          , ni = Object.prototype
          , Xr = ni.hasOwnProperty
          , qr = ni.toString
          , ve = ri ? ri.toStringTag : void 0;
        function Wr(e) {
            var t = Xr.call(e, ve)
              , i = e[ve];
            try {
                e[ve] = void 0;
                var r = !0
            } catch (s) {}
            var n = qr.call(e);
            return r && (t ? e[ve] = i : delete e[ve]),
            n
        }
        si.exports = Wr
    }
    );
    var li = P( (es, ai) => {
        var Kr = Object.prototype
          , Gr = Kr.toString;
        function Yr(e) {
            return Gr.call(e)
        }
        ai.exports = Yr
    }
    );
    var ui = P( (ts, ci) => {
        var hi = st()
          , Qr = oi()
          , Zr = li()
          , en = "[object Null]"
          , tn = "[object Undefined]"
          , di = hi ? hi.toStringTag : void 0;
        function rn(e) {
            return e == null ? e === void 0 ? tn : en : di && di in Object(e) ? Qr(e) : Zr(e)
        }
        ci.exports = rn
    }
    );
    var pi = P( (is, fi) => {
        function nn(e) {
            return e != null && typeof e == "object"
        }
        fi.exports = nn
    }
    );
    var mi = P( (rs, gi) => {
        var sn = ui()
          , on = pi()
          , an = "[object Symbol]";
        function ln(e) {
            return typeof e == "symbol" || on(e) && sn(e) == an
        }
        gi.exports = ln
    }
    );
    var wi = P( (ns, yi) => {
        var hn = ti()
          , vi = rt()
          , dn = mi()
          , bi = NaN
          , cn = /^[-+]0x[0-9a-f]+$/i
          , un = /^0b[01]+$/i
          , fn = /^0o[0-7]+$/i
          , pn = parseInt;
        function gn(e) {
            if (typeof e == "number")
                return e;
            if (dn(e))
                return bi;
            if (vi(e)) {
                var t = typeof e.valueOf == "function" ? e.valueOf() : e;
                e = vi(t) ? t + "" : t
            }
            if (typeof e != "string")
                return e === 0 ? e : +e;
            e = hn(e);
            var i = un.test(e);
            return i || fn.test(e) ? pn(e.slice(2), i ? 2 : 8) : cn.test(e) ? bi : +e
        }
        yi.exports = gn
    }
    );
    var xi = P( (ss, Si) => {
        var mn = rt()
          , ot = Yt()
          , ki = wi()
          , vn = "Expected a function"
          , bn = Math.max
          , yn = Math.min;
        function wn(e, t, i) {
            var r, n, s, o, a, l, d = 0, f = !1, h = !1, p = !0;
            if (typeof e != "function")
                throw new TypeError(vn);
            t = ki(t) || 0,
            mn(i) && (f = !!i.leading,
            h = "maxWait"in i,
            s = h ? bn(ki(i.maxWait) || 0, t) : s,
            p = "trailing"in i ? !!i.trailing : p);
            function g(x) {
                var L = r
                  , Q = n;
                return r = n = void 0,
                d = x,
                o = e.apply(Q, L),
                o
            }
            function y(x) {
                return d = x,
                a = setTimeout(C, t),
                f ? g(x) : o
            }
            function m(x) {
                var L = x - l
                  , Q = x - d
                  , E = t - L;
                return h ? yn(E, s - Q) : E
            }
            function A(x) {
                var L = x - l
                  , Q = x - d;
                return l === void 0 || L >= t || L < 0 || h && Q >= s
            }
            function C() {
                var x = ot();
                if (A(x))
                    return B(x);
                a = setTimeout(C, m(x))
            }
            function B(x) {
                return a = void 0,
                p && r ? g(x) : (r = n = void 0,
                o)
            }
            function u() {
                a !== void 0 && clearTimeout(a),
                d = 0,
                r = l = n = a = void 0
            }
            function S() {
                return a === void 0 ? o : B(ot())
            }
            function V() {
                var x = ot()
                  , L = A(x);
                if (r = arguments,
                n = this,
                l = x,
                L) {
                    if (a === void 0)
                        return y(l);
                    if (h)
                        return clearTimeout(a),
                        a = setTimeout(C, t),
                        g(l)
                }
                return a === void 0 && (a = setTimeout(C, t)),
                o
            }
            return V.cancel = u,
            V.flush = S,
            V
        }
        Si.exports = wn
    }
    );
    (function() {
        var e = t();
        function t() {
            if (typeof window.CustomEvent == "function")
                return window.CustomEvent;
            function n(s, o) {
                o = o || {
                    bubbles: !1,
                    cancelable: !1,
                    detail: void 0
                };
                var a = document.createEvent("CustomEvent");
                return a.initCustomEvent(s, o.bubbles, o.cancelable, o.detail),
                a
            }
            return n.prototype = window.Event.prototype,
            n
        }
        function i(n, s) {
            var o = document.createElement("input");
            return o.type = "hidden",
            o.name = n,
            o.value = s,
            o
        }
        function r(n, s) {
            var o = n.getAttribute("data-to")
              , a = i("_method", n.getAttribute("data-method"))
              , l = i("_csrf_token", n.getAttribute("data-csrf"))
              , d = document.createElement("form")
              , f = document.createElement("input")
              , h = n.getAttribute("target");
            d.method = n.getAttribute("data-method") === "get" ? "get" : "post",
            d.action = o,
            d.style.display = "none",
            h ? d.target = h : s && (d.target = "_blank"),
            d.appendChild(l),
            d.appendChild(a),
            document.body.appendChild(d),
            f.type = "submit",
            d.appendChild(f),
            f.click()
        }
        window.addEventListener("click", function(n) {
            var s = n.target;
            if (!n.defaultPrevented)
                for (; s && s.getAttribute; ) {
                    var o = new e("phoenix.link.click",{
                        bubbles: !0,
                        cancelable: !0
                    });
                    if (!s.dispatchEvent(o))
                        return n.preventDefault(),
                        n.stopImmediatePropagation(),
                        !1;
                    if (s.getAttribute("data-method"))
                        return r(s, n.metaKey || n.shiftKey),
                        n.preventDefault(),
                        !1;
                    s = s.parentNode
                }
        }, !1),
        window.addEventListener("phoenix.link.click", function(n) {
            var s = n.target.getAttribute("data-confirm");
            s && !window.confirm(s) && n.preventDefault()
        }, !1)
    }
    )();
    var ae = e => typeof e == "function" ? e : function() {
        return e
    }
      , Ni = typeof self != "undefined" ? self : null
      , oe = typeof window != "undefined" ? window : null
      , le = Ni || oe || le
      , Hi = "2.0.0"
      , j = {
        connecting: 0,
        open: 1,
        closing: 2,
        closed: 3
    }
      , ji = 1e4
      , Mi = 1e3
      , I = {
        closed: "closed",
        errored: "errored",
        joined: "joined",
        joining: "joining",
        leaving: "leaving"
    }
      , J = {
        close: "phx_close",
        error: "phx_error",
        join: "phx_join",
        reply: "phx_reply",
        leave: "phx_leave"
    }
      , $e = {
        longpoll: "longpoll",
        websocket: "websocket"
    }
      , Ui = {
        complete: 4
    }
      , ke = class {
        constructor(e, t, i, r) {
            this.channel = e,
            this.event = t,
            this.payload = i || function() {
                return {}
            }
            ,
            this.receivedResp = null,
            this.timeout = r,
            this.timeoutTimer = null,
            this.recHooks = [],
            this.sent = !1
        }
        resend(e) {
            this.timeout = e,
            this.reset(),
            this.send()
        }
        send() {
            this.hasReceived("timeout") || (this.startTimeout(),
            this.sent = !0,
            this.channel.socket.push({
                topic: this.channel.topic,
                event: this.event,
                payload: this.payload(),
                ref: this.ref,
                join_ref: this.channel.joinRef()
            }))
        }
        receive(e, t) {
            return this.hasReceived(e) && t(this.receivedResp.response),
            this.recHooks.push({
                status: e,
                callback: t
            }),
            this
        }
        reset() {
            this.cancelRefEvent(),
            this.ref = null,
            this.refEvent = null,
            this.receivedResp = null,
            this.sent = !1
        }
        matchReceive({status: e, response: t, _ref: i}) {
            this.recHooks.filter(r => r.status === e).forEach(r => r.callback(t))
        }
        cancelRefEvent() {
            this.refEvent && this.channel.off(this.refEvent)
        }
        cancelTimeout() {
            clearTimeout(this.timeoutTimer),
            this.timeoutTimer = null
        }
        startTimeout() {
            this.timeoutTimer && this.cancelTimeout(),
            this.ref = this.channel.socket.makeRef(),
            this.refEvent = this.channel.replyEventName(this.ref),
            this.channel.on(this.refEvent, e => {
                this.cancelRefEvent(),
                this.cancelTimeout(),
                this.receivedResp = e,
                this.matchReceive(e)
            }
            ),
            this.timeoutTimer = setTimeout( () => {
                this.trigger("timeout", {})
            }
            , this.timeout)
        }
        hasReceived(e) {
            return this.receivedResp && this.receivedResp.status === e
        }
        trigger(e, t) {
            this.channel.trigger(this.refEvent, {
                status: e,
                response: t
            })
        }
    }
      , ft = class {
        constructor(e, t) {
            this.callback = e,
            this.timerCalc = t,
            this.timer = null,
            this.tries = 0
        }
        reset() {
            this.tries = 0,
            clearTimeout(this.timer)
        }
        scheduleTimeout() {
            clearTimeout(this.timer),
            this.timer = setTimeout( () => {
                this.tries = this.tries + 1,
                this.callback()
            }
            , this.timerCalc(this.tries + 1))
        }
    }
      , $i = class {
        constructor(e, t, i) {
            this.state = I.closed,
            this.topic = e,
            this.params = ae(t || {}),
            this.socket = i,
            this.bindings = [],
            this.bindingRef = 0,
            this.timeout = this.socket.timeout,
            this.joinedOnce = !1,
            this.joinPush = new ke(this,J.join,this.params,this.timeout),
            this.pushBuffer = [],
            this.stateChangeRefs = [],
            this.rejoinTimer = new ft( () => {
                this.socket.isConnected() && this.rejoin()
            }
            ,this.socket.rejoinAfterMs),
            this.stateChangeRefs.push(this.socket.onError( () => this.rejoinTimer.reset())),
            this.stateChangeRefs.push(this.socket.onOpen( () => {
                this.rejoinTimer.reset(),
                this.isErrored() && this.rejoin()
            }
            )),
            this.joinPush.receive("ok", () => {
                this.state = I.joined,
                this.rejoinTimer.reset(),
                this.pushBuffer.forEach(r => r.send()),
                this.pushBuffer = []
            }
            ),
            this.joinPush.receive("error", () => {
                this.state = I.errored,
                this.socket.isConnected() && this.rejoinTimer.scheduleTimeout()
            }
            ),
            this.onClose( () => {
                this.rejoinTimer.reset(),
                this.socket.hasLogger() && this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`),
                this.state = I.closed,
                this.socket.remove(this)
            }
            ),
            this.onError(r => {
                this.socket.hasLogger() && this.socket.log("channel", `error ${this.topic}`, r),
                this.isJoining() && this.joinPush.reset(),
                this.state = I.errored,
                this.socket.isConnected() && this.rejoinTimer.scheduleTimeout()
            }
            ),
            this.joinPush.receive("timeout", () => {
                this.socket.hasLogger() && this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout),
                new ke(this,J.leave,ae({}),this.timeout).send(),
                this.state = I.errored,
                this.joinPush.reset(),
                this.socket.isConnected() && this.rejoinTimer.scheduleTimeout()
            }
            ),
            this.on(J.reply, (r, n) => {
                this.trigger(this.replyEventName(n), r)
            }
            )
        }
        join(e=this.timeout) {
            if (this.joinedOnce)
                throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
            return this.timeout = e,
            this.joinedOnce = !0,
            this.rejoin(),
            this.joinPush
        }
        onClose(e) {
            this.on(J.close, e)
        }
        onError(e) {
            return this.on(J.error, t => e(t))
        }
        on(e, t) {
            let i = this.bindingRef++;
            return this.bindings.push({
                event: e,
                ref: i,
                callback: t
            }),
            i
        }
        off(e, t) {
            this.bindings = this.bindings.filter(i => !(i.event === e && (typeof t == "undefined" || t === i.ref)))
        }
        canPush() {
            return this.socket.isConnected() && this.isJoined()
        }
        push(e, t, i=this.timeout) {
            if (t = t || {},
            !this.joinedOnce)
                throw new Error(`tried to push '${e}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
            let r = new ke(this,e,function() {
                return t
            }
            ,i);
            return this.canPush() ? r.send() : (r.startTimeout(),
            this.pushBuffer.push(r)),
            r
        }
        leave(e=this.timeout) {
            this.rejoinTimer.reset(),
            this.joinPush.cancelTimeout(),
            this.state = I.leaving;
            let t = () => {
                this.socket.hasLogger() && this.socket.log("channel", `leave ${this.topic}`),
                this.trigger(J.close, "leave")
            }
              , i = new ke(this,J.leave,ae({}),e);
            return i.receive("ok", () => t()).receive("timeout", () => t()),
            i.send(),
            this.canPush() || i.trigger("ok", {}),
            i
        }
        onMessage(e, t, i) {
            return t
        }
        isMember(e, t, i, r) {
            return this.topic !== e ? !1 : r && r !== this.joinRef() ? (this.socket.hasLogger() && this.socket.log("channel", "dropping outdated message", {
                topic: e,
                event: t,
                payload: i,
                joinRef: r
            }),
            !1) : !0
        }
        joinRef() {
            return this.joinPush.ref
        }
        rejoin(e=this.timeout) {
            this.isLeaving() || (this.socket.leaveOpenTopic(this.topic),
            this.state = I.joining,
            this.joinPush.resend(e))
        }
        trigger(e, t, i, r) {
            let n = this.onMessage(e, t, i, r);
            if (t && !n)
                throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
            let s = this.bindings.filter(o => o.event === e);
            for (let o = 0; o < s.length; o++)
                s[o].callback(n, i, r || this.joinRef())
        }
        replyEventName(e) {
            return `chan_reply_${e}`
        }
        isClosed() {
            return this.state === I.closed
        }
        isErrored() {
            return this.state === I.errored
        }
        isJoined() {
            return this.state === I.joined
        }
        isJoining() {
            return this.state === I.joining
        }
        isLeaving() {
            return this.state === I.leaving
        }
    }
      , xe = class {
        static request(e, t, i, r, n, s, o) {
            if (le.XDomainRequest) {
                let a = new le.XDomainRequest;
                return this.xdomainRequest(a, e, t, r, n, s, o)
            } else {
                let a = new le.XMLHttpRequest;
                return this.xhrRequest(a, e, t, i, r, n, s, o)
            }
        }
        static xdomainRequest(e, t, i, r, n, s, o) {
            return e.timeout = n,
            e.open(t, i),
            e.onload = () => {
                let a = this.parseJSON(e.responseText);
                o && o(a)
            }
            ,
            s && (e.ontimeout = s),
            e.onprogress = () => {}
            ,
            e.send(r),
            e
        }
        static xhrRequest(e, t, i, r, n, s, o, a) {
            return e.open(t, i, !0),
            e.timeout = s,
            e.setRequestHeader("Content-Type", r),
            e.onerror = () => a && a(null),
            e.onreadystatechange = () => {
                if (e.readyState === Ui.complete && a) {
                    let l = this.parseJSON(e.responseText);
                    a(l)
                }
            }
            ,
            o && (e.ontimeout = o),
            e.send(n),
            e
        }
        static parseJSON(e) {
            if (!e || e === "")
                return null;
            try {
                return JSON.parse(e)
            } catch (t) {
                return console && console.log("failed to parse JSON response", e),
                null
            }
        }
        static serialize(e, t) {
            let i = [];
            for (var r in e) {
                if (!Object.prototype.hasOwnProperty.call(e, r))
                    continue;
                let n = t ? `${t}[${r}]` : r
                  , s = e[r];
                typeof s == "object" ? i.push(this.serialize(s, n)) : i.push(encodeURIComponent(n) + "=" + encodeURIComponent(s))
            }
            return i.join("&")
        }
        static appendParams(e, t) {
            if (Object.keys(t).length === 0)
                return e;
            let i = e.match(/\?/) ? "&" : "?";
            return `${e}${i}${this.serialize(t)}`
        }
    }
      , Ue = class {
        constructor(e) {
            this.endPoint = null,
            this.token = null,
            this.skipHeartbeat = !0,
            this.reqs = new Set,
            this.onopen = function() {}
            ,
            this.onerror = function() {}
            ,
            this.onmessage = function() {}
            ,
            this.onclose = function() {}
            ,
            this.pollEndpoint = this.normalizeEndpoint(e),
            this.readyState = j.connecting,
            this.poll()
        }
        normalizeEndpoint(e) {
            return e.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + $e.websocket), "$1/" + $e.longpoll)
        }
        endpointURL() {
            return xe.appendParams(this.pollEndpoint, {
                token: this.token
            })
        }
        closeAndRetry(e, t, i) {
            this.close(e, t, i),
            this.readyState = j.connecting
        }
        ontimeout() {
            this.onerror("timeout"),
            this.closeAndRetry(1005, "timeout", !1)
        }
        isActive() {
            return this.readyState === j.open || this.readyState === j.connecting
        }
        poll() {
            this.ajax("GET", null, () => this.ontimeout(), e => {
                if (e) {
                    var {status: t, token: i, messages: r} = e;
                    this.token = i
                } else
                    t = 0;
                switch (t) {
                case 200:
                    r.forEach(n => {
                        setTimeout( () => this.onmessage({
                            data: n
                        }), 0)
                    }
                    ),
                    this.poll();
                    break;
                case 204:
                    this.poll();
                    break;
                case 410:
                    this.readyState = j.open,
                    this.onopen({}),
                    this.poll();
                    break;
                case 403:
                    this.onerror(403),
                    this.close(1008, "forbidden", !1);
                    break;
                case 0:
                case 500:
                    this.onerror(500),
                    this.closeAndRetry(1011, "internal server error", 500);
                    break;
                default:
                    throw new Error(`unhandled poll status ${t}`)
                }
            }
            )
        }
        send(e) {
            this.ajax("POST", e, () => this.onerror("timeout"), t => {
                (!t || t.status !== 200) && (this.onerror(t && t.status),
                this.closeAndRetry(1011, "internal server error", !1))
            }
            )
        }
        close(e, t, i) {
            for (let n of this.reqs)
                n.abort();
            this.readyState = j.closed;
            let r = Object.assign({
                code: 1e3,
                reason: void 0,
                wasClean: !0
            }, {
                code: e,
                reason: t,
                wasClean: i
            });
            typeof CloseEvent != "undefined" ? this.onclose(new CloseEvent("close",r)) : this.onclose(r)
        }
        ajax(e, t, i, r) {
            let n, s = () => {
                this.reqs.delete(n),
                i()
            }
            ;
            n = xe.request(e, this.endpointURL(), "application/json", t, this.timeout, s, o => {
                this.reqs.delete(n),
                this.isActive() && r(o)
            }
            ),
            this.reqs.add(n)
        }
    }
    ;
    var Se = {
        HEADER_LENGTH: 1,
        META_LENGTH: 4,
        KINDS: {
            push: 0,
            reply: 1,
            broadcast: 2
        },
        encode(e, t) {
            if (e.payload.constructor === ArrayBuffer)
                return t(this.binaryEncode(e));
            {
                let i = [e.join_ref, e.ref, e.topic, e.event, e.payload];
                return t(JSON.stringify(i))
            }
        },
        decode(e, t) {
            if (e.constructor === ArrayBuffer)
                return t(this.binaryDecode(e));
            {
                let[i,r,n,s,o] = JSON.parse(e);
                return t({
                    join_ref: i,
                    ref: r,
                    topic: n,
                    event: s,
                    payload: o
                })
            }
        },
        binaryEncode(e) {
            let {join_ref: t, ref: i, event: r, topic: n, payload: s} = e
              , o = this.META_LENGTH + t.length + i.length + n.length + r.length
              , a = new ArrayBuffer(this.HEADER_LENGTH + o)
              , l = new DataView(a)
              , d = 0;
            l.setUint8(d++, this.KINDS.push),
            l.setUint8(d++, t.length),
            l.setUint8(d++, i.length),
            l.setUint8(d++, n.length),
            l.setUint8(d++, r.length),
            Array.from(t, h => l.setUint8(d++, h.charCodeAt(0))),
            Array.from(i, h => l.setUint8(d++, h.charCodeAt(0))),
            Array.from(n, h => l.setUint8(d++, h.charCodeAt(0))),
            Array.from(r, h => l.setUint8(d++, h.charCodeAt(0)));
            var f = new Uint8Array(a.byteLength + s.byteLength);
            return f.set(new Uint8Array(a), 0),
            f.set(new Uint8Array(s), a.byteLength),
            f.buffer
        },
        binaryDecode(e) {
            let t = new DataView(e)
              , i = t.getUint8(0)
              , r = new TextDecoder;
            switch (i) {
            case this.KINDS.push:
                return this.decodePush(e, t, r);
            case this.KINDS.reply:
                return this.decodeReply(e, t, r);
            case this.KINDS.broadcast:
                return this.decodeBroadcast(e, t, r)
            }
        },
        decodePush(e, t, i) {
            let r = t.getUint8(1)
              , n = t.getUint8(2)
              , s = t.getUint8(3)
              , o = this.HEADER_LENGTH + this.META_LENGTH - 1
              , a = i.decode(e.slice(o, o + r));
            o = o + r;
            let l = i.decode(e.slice(o, o + n));
            o = o + n;
            let d = i.decode(e.slice(o, o + s));
            o = o + s;
            let f = e.slice(o, e.byteLength);
            return {
                join_ref: a,
                ref: null,
                topic: l,
                event: d,
                payload: f
            }
        },
        decodeReply(e, t, i) {
            let r = t.getUint8(1)
              , n = t.getUint8(2)
              , s = t.getUint8(3)
              , o = t.getUint8(4)
              , a = this.HEADER_LENGTH + this.META_LENGTH
              , l = i.decode(e.slice(a, a + r));
            a = a + r;
            let d = i.decode(e.slice(a, a + n));
            a = a + n;
            let f = i.decode(e.slice(a, a + s));
            a = a + s;
            let h = i.decode(e.slice(a, a + o));
            a = a + o;
            let p = e.slice(a, e.byteLength)
              , g = {
                status: h,
                response: p
            };
            return {
                join_ref: l,
                ref: d,
                topic: f,
                event: J.reply,
                payload: g
            }
        },
        decodeBroadcast(e, t, i) {
            let r = t.getUint8(1)
              , n = t.getUint8(2)
              , s = this.HEADER_LENGTH + 2
              , o = i.decode(e.slice(s, s + r));
            s = s + r;
            let a = i.decode(e.slice(s, s + n));
            s = s + n;
            let l = e.slice(s, e.byteLength);
            return {
                join_ref: null,
                ref: null,
                topic: o,
                event: a,
                payload: l
            }
        }
    }
      , pt = class {
        constructor(e, t={}) {
            this.stateChangeCallbacks = {
                open: [],
                close: [],
                error: [],
                message: []
            },
            this.channels = [],
            this.sendBuffer = [],
            this.ref = 0,
            this.timeout = t.timeout || ji,
            this.transport = t.transport || le.WebSocket || Ue,
            this.establishedConnections = 0,
            this.defaultEncoder = Se.encode.bind(Se),
            this.defaultDecoder = Se.decode.bind(Se),
            this.closeWasClean = !1,
            this.binaryType = t.binaryType || "arraybuffer",
            this.connectClock = 1,
            this.transport !== Ue ? (this.encode = t.encode || this.defaultEncoder,
            this.decode = t.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder,
            this.decode = this.defaultDecoder);
            let i = null;
            oe && oe.addEventListener && (oe.addEventListener("pagehide", r => {
                this.conn && (this.disconnect(),
                i = this.connectClock)
            }
            ),
            oe.addEventListener("pageshow", r => {
                i === this.connectClock && (i = null,
                this.connect())
            }
            )),
            this.heartbeatIntervalMs = t.heartbeatIntervalMs || 3e4,
            this.rejoinAfterMs = r => t.rejoinAfterMs ? t.rejoinAfterMs(r) : [1e3, 2e3, 5e3][r - 1] || 1e4,
            this.reconnectAfterMs = r => t.reconnectAfterMs ? t.reconnectAfterMs(r) : [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][r - 1] || 5e3,
            this.logger = t.logger || null,
            this.longpollerTimeout = t.longpollerTimeout || 2e4,
            this.params = ae(t.params || {}),
            this.endPoint = `${e}/${$e.websocket}`,
            this.vsn = t.vsn || Hi,
            this.heartbeatTimeoutTimer = null,
            this.heartbeatTimer = null,
            this.pendingHeartbeatRef = null,
            this.reconnectTimer = new ft( () => {
                this.teardown( () => this.connect())
            }
            ,this.reconnectAfterMs)
        }
        getLongPollTransport() {
            return Ue
        }
        replaceTransport(e) {
            this.connectClock++,
            this.closeWasClean = !0,
            this.reconnectTimer.reset(),
            this.sendBuffer = [],
            this.conn && (this.conn.close(),
            this.conn = null),
            this.transport = e
        }
        protocol() {
            return location.protocol.match(/^https/) ? "wss" : "ws"
        }
        endPointURL() {
            let e = xe.appendParams(xe.appendParams(this.endPoint, this.params()), {
                vsn: this.vsn
            });
            return e.charAt(0) !== "/" ? e : e.charAt(1) === "/" ? `${this.protocol()}:${e}` : `${this.protocol()}://${location.host}${e}`
        }
        disconnect(e, t, i) {
            this.connectClock++,
            this.closeWasClean = !0,
            this.reconnectTimer.reset(),
            this.teardown(e, t, i)
        }
        connect(e) {
            e && (console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor"),
            this.params = ae(e)),
            !this.conn && (this.connectClock++,
            this.closeWasClean = !1,
            this.conn = new this.transport(this.endPointURL()),
            this.conn.binaryType = this.binaryType,
            this.conn.timeout = this.longpollerTimeout,
            this.conn.onopen = () => this.onConnOpen(),
            this.conn.onerror = t => this.onConnError(t),
            this.conn.onmessage = t => this.onConnMessage(t),
            this.conn.onclose = t => this.onConnClose(t))
        }
        log(e, t, i) {
            this.logger(e, t, i)
        }
        hasLogger() {
            return this.logger !== null
        }
        onOpen(e) {
            let t = this.makeRef();
            return this.stateChangeCallbacks.open.push([t, e]),
            t
        }
        onClose(e) {
            let t = this.makeRef();
            return this.stateChangeCallbacks.close.push([t, e]),
            t
        }
        onError(e) {
            let t = this.makeRef();
            return this.stateChangeCallbacks.error.push([t, e]),
            t
        }
        onMessage(e) {
            let t = this.makeRef();
            return this.stateChangeCallbacks.message.push([t, e]),
            t
        }
        ping(e) {
            if (!this.isConnected())
                return !1;
            let t = this.makeRef()
              , i = Date.now();
            this.push({
                topic: "phoenix",
                event: "heartbeat",
                payload: {},
                ref: t
            });
            let r = this.onMessage(n => {
                n.ref === t && (this.off([r]),
                e(Date.now() - i))
            }
            );
            return !0
        }
        clearHeartbeats() {
            clearTimeout(this.heartbeatTimer),
            clearTimeout(this.heartbeatTimeoutTimer)
        }
        onConnOpen() {
            this.hasLogger() && this.log("transport", `connected to ${this.endPointURL()}`),
            this.closeWasClean = !1,
            this.establishedConnections++,
            this.flushSendBuffer(),
            this.reconnectTimer.reset(),
            this.resetHeartbeat(),
            this.stateChangeCallbacks.open.forEach( ([,e]) => e())
        }
        heartbeatTimeout() {
            this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null,
            this.hasLogger() && this.log("transport", "heartbeat timeout. Attempting to re-establish connection"),
            this.triggerChanError(),
            this.closeWasClean = !1,
            this.teardown( () => this.reconnectTimer.scheduleTimeout(), Mi, "heartbeat timeout"))
        }
        resetHeartbeat() {
            this.conn && this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null,
            this.clearHeartbeats(),
            this.heartbeatTimer = setTimeout( () => this.sendHeartbeat(), this.heartbeatIntervalMs))
        }
        teardown(e, t, i) {
            if (!this.conn)
                return e && e();
            this.waitForBufferDone( () => {
                this.conn && (t ? this.conn.close(t, i || "") : this.conn.close()),
                this.waitForSocketClosed( () => {
                    this.conn && (this.conn.onopen = function() {}
                    ,
                    this.conn.onerror = function() {}
                    ,
                    this.conn.onmessage = function() {}
                    ,
                    this.conn.onclose = function() {}
                    ,
                    this.conn = null),
                    e && e()
                }
                )
            }
            )
        }
        waitForBufferDone(e, t=1) {
            if (t === 5 || !this.conn || !this.conn.bufferedAmount) {
                e();
                return
            }
            setTimeout( () => {
                this.waitForBufferDone(e, t + 1)
            }
            , 150 * t)
        }
        waitForSocketClosed(e, t=1) {
            if (t === 5 || !this.conn || this.conn.readyState === j.closed) {
                e();
                return
            }
            setTimeout( () => {
                this.waitForSocketClosed(e, t + 1)
            }
            , 150 * t)
        }
        onConnClose(e) {
            let t = e && e.code;
            this.hasLogger() && this.log("transport", "close", e),
            this.triggerChanError(),
            this.clearHeartbeats(),
            !this.closeWasClean && t !== 1e3 && this.reconnectTimer.scheduleTimeout(),
            this.stateChangeCallbacks.close.forEach( ([,i]) => i(e))
        }
        onConnError(e) {
            this.hasLogger() && this.log("transport", e);
            let t = this.transport
              , i = this.establishedConnections;
            this.stateChangeCallbacks.error.forEach( ([,r]) => {
                r(e, t, i)
            }
            ),
            (t === this.transport || i > 0) && this.triggerChanError()
        }
        triggerChanError() {
            this.channels.forEach(e => {
                e.isErrored() || e.isLeaving() || e.isClosed() || e.trigger(J.error)
            }
            )
        }
        connectionState() {
            switch (this.conn && this.conn.readyState) {
            case j.connecting:
                return "connecting";
            case j.open:
                return "open";
            case j.closing:
                return "closing";
            default:
                return "closed"
            }
        }
        isConnected() {
            return this.connectionState() === "open"
        }
        remove(e) {
            this.off(e.stateChangeRefs),
            this.channels = this.channels.filter(t => t.joinRef() !== e.joinRef())
        }
        off(e) {
            for (let t in this.stateChangeCallbacks)
                this.stateChangeCallbacks[t] = this.stateChangeCallbacks[t].filter( ([i]) => e.indexOf(i) === -1)
        }
        channel(e, t={}) {
            let i = new $i(e,t,this);
            return this.channels.push(i),
            i
        }
        push(e) {
            if (this.hasLogger()) {
                let {topic: t, event: i, payload: r, ref: n, join_ref: s} = e;
                this.log("push", `${t} ${i} (${s}, ${n})`, r)
            }
            this.isConnected() ? this.encode(e, t => this.conn.send(t)) : this.sendBuffer.push( () => this.encode(e, t => this.conn.send(t)))
        }
        makeRef() {
            let e = this.ref + 1;
            return e === this.ref ? this.ref = 0 : this.ref = e,
            this.ref.toString()
        }
        sendHeartbeat() {
            this.pendingHeartbeatRef && !this.isConnected() || (this.pendingHeartbeatRef = this.makeRef(),
            this.push({
                topic: "phoenix",
                event: "heartbeat",
                payload: {},
                ref: this.pendingHeartbeatRef
            }),
            this.heartbeatTimeoutTimer = setTimeout( () => this.heartbeatTimeout(), this.heartbeatIntervalMs))
        }
        flushSendBuffer() {
            this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()),
            this.sendBuffer = [])
        }
        onConnMessage(e) {
            this.decode(e.data, t => {
                let {topic: i, event: r, payload: n, ref: s, join_ref: o} = t;
                s && s === this.pendingHeartbeatRef && (this.clearHeartbeats(),
                this.pendingHeartbeatRef = null,
                this.heartbeatTimer = setTimeout( () => this.sendHeartbeat(), this.heartbeatIntervalMs)),
                this.hasLogger() && this.log("receive", `${n.status || ""} ${i} ${r} ${s && "(" + s + ")" || ""}`, n);
                for (let a = 0; a < this.channels.length; a++) {
                    let l = this.channels[a];
                    l.isMember(i, r, n, o) && l.trigger(r, n, s, o)
                }
                for (let a = 0; a < this.stateChangeCallbacks.message.length; a++) {
                    let[,l] = this.stateChangeCallbacks.message[a];
                    l(t)
                }
            }
            )
        }
        leaveOpenTopic(e) {
            let t = this.channels.find(i => i.topic === e && (i.isJoined() || i.isJoining()));
            t && (this.hasLogger() && this.log("transport", `leaving duplicate topic "${e}"`),
            t.leave())
        }
    }
    ;
    var Oe = ut(mt());
    var jt = "consecutive-reloads"
      , Fi = 10
      , Bi = 5e3
      , Ji = 1e4
      , zi = 3e4
      , Mt = ["phx-click-loading", "phx-change-loading", "phx-submit-loading", "phx-keydown-loading", "phx-keyup-loading", "phx-blur-loading", "phx-focus-loading"]
      , O = "data-phx-component"
      , Fe = "data-phx-link"
      , Vi = "track-static"
      , Xi = "data-phx-link-state"
      , F = "data-phx-ref"
      , ee = "data-phx-ref-src"
      , Ut = "track-uploads"
      , te = "data-phx-upload-ref"
      , tt = "data-phx-preflighted-refs"
      , qi = "data-phx-done-refs"
      , vt = "drop-target"
      , Ke = "data-phx-active-refs"
      , Ge = "phx:live-file:updated"
      , Ye = "data-phx-skip"
      , bt = "data-phx-prune"
      , yt = "page-loading"
      , wt = "phx-connected"
      , Be = "phx-loading"
      , kt = "phx-no-feedback"
      , St = "phx-error"
      , re = "data-phx-parent-id"
      , it = "data-phx-main"
      , me = "data-phx-root-id"
      , Wi = "trigger-action"
      , Qe = "feedback-for"
      , $t = "phx-has-focused"
      , Ki = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"]
      , Ft = ["checkbox", "radio"]
      , Bt = "phx-has-submitted"
      , Y = "data-phx-session"
      , ne = `[${Y}]`
      , xt = "data-phx-sticky"
      , pe = "data-phx-static"
      , Je = "data-phx-readonly"
      , Ee = "data-phx-disabled"
      , Ze = "disable-with"
      , Ce = "data-phx-disable-with-restore"
      , he = "hook"
      , Gi = "debounce"
      , Yi = "throttle"
      , et = "update"
      , Qi = "key"
      , M = "phxPrivate"
      , At = "auto-recover"
      , Te = "phx:live-socket:debug"
      , ze = "phx:live-socket:profiling"
      , Ve = "phx:live-socket:latency-sim"
      , Zi = "progress"
      , er = 1
      , tr = 200
      , ir = "phx-"
      , rr = 3e4
      , de = "debounce-trigger"
      , _e = "throttled"
      , Et = "debounce-prev-key"
      , nr = {
        debounce: 300,
        throttle: 300
    }
      , Ct = "d"
      , U = "s"
      , D = "c"
      , Tt = "e"
      , _t = "r"
      , Pt = "t"
      , sr = "p"
      , or = class {
        constructor(e, t, i) {
            this.liveSocket = i,
            this.entry = e,
            this.offset = 0,
            this.chunkSize = t,
            this.chunkTimer = null,
            this.uploadChannel = i.channel(`lvu:${e.ref}`, {
                token: e.metadata()
            })
        }
        error(e) {
            clearTimeout(this.chunkTimer),
            this.uploadChannel.leave(),
            this.entry.error(e)
        }
        upload() {
            this.uploadChannel.onError(e => this.error(e)),
            this.uploadChannel.join().receive("ok", e => this.readNextChunk()).receive("error", e => this.error(e))
        }
        isDone() {
            return this.offset >= this.entry.file.size
        }
        readNextChunk() {
            let e = new window.FileReader
              , t = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
            e.onload = i => {
                if (i.target.error === null)
                    this.offset += i.target.result.byteLength,
                    this.pushChunk(i.target.result);
                else
                    return _("Read error: " + i.target.error)
            }
            ,
            e.readAsArrayBuffer(t)
        }
        pushChunk(e) {
            this.uploadChannel.isJoined() && this.uploadChannel.push("chunk", e).receive("ok", () => {
                this.entry.progress(this.offset / this.entry.file.size * 100),
                this.isDone() || (this.chunkTimer = setTimeout( () => this.readNextChunk(), this.liveSocket.getLatencySim() || 0))
            }
            )
        }
    }
      , _ = (e, t) => console.error && console.error(e, t)
      , G = e => {
        let t = typeof e;
        return t === "number" || t === "string" && /^(0|[1-9]\d*)$/.test(e)
    }
    ;
    function ar() {
        let e = new Set
          , t = document.querySelectorAll("*[id]");
        for (let i = 0, r = t.length; i < r; i++)
            e.has(t[i].id) ? console.error(`Multiple IDs detected: ${t[i].id}. Ensure unique element ids.`) : e.add(t[i].id)
    }
    var lr = (e, t, i, r) => {
        e.liveSocket.isDebugEnabled() && console.log(`${e.id} ${t}: ${i} - `, r)
    }
      , Xe = e => typeof e == "function" ? e : function() {
        return e
    }
      , De = e => JSON.parse(JSON.stringify(e))
      , ge = (e, t, i) => {
        do {
            if (e.matches(`[${t}]`))
                return e;
            e = e.parentElement || e.parentNode
        } while (e !== null && e.nodeType === 1 && !(i && i.isSameNode(e) || e.matches(ne)));
        return null
    }
      , ce = e => e !== null && typeof e == "object" && !(e instanceof Array)
      , hr = (e, t) => JSON.stringify(e) === JSON.stringify(t)
      , Rt = e => {
        for (let t in e)
            return !1;
        return !0
    }
      , z = (e, t) => e && t(e)
      , dr = function(e, t, i, r) {
        e.forEach(n => {
            new or(n,i.config.chunk_size,r).upload()
        }
        )
    }
      , Jt = {
        canPushState() {
            return typeof history.pushState != "undefined"
        },
        dropLocal(e, t, i) {
            return e.removeItem(this.localKey(t, i))
        },
        updateLocal(e, t, i, r, n) {
            let s = this.getLocal(e, t, i)
              , o = this.localKey(t, i)
              , a = s === null ? r : n(s);
            return e.setItem(o, JSON.stringify(a)),
            a
        },
        getLocal(e, t, i) {
            return JSON.parse(e.getItem(this.localKey(t, i)))
        },
        updateCurrentState(e) {
            this.canPushState() && history.replaceState(e(history.state || {}), "", window.location.href)
        },
        pushState(e, t, i) {
            if (this.canPushState()) {
                if (i !== window.location.href) {
                    if (t.type == "redirect" && t.scroll) {
                        let n = history.state || {};
                        n.scroll = t.scroll,
                        history.replaceState(n, "", window.location.href)
                    }
                    delete t.scroll,
                    history[e + "State"](t, "", i || null);
                    let r = this.getHashTargetEl(window.location.hash);
                    r ? r.scrollIntoView() : t.type === "redirect" && window.scroll(0, 0)
                }
            } else
                this.redirect(i)
        },
        setCookie(e, t) {
            document.cookie = `${e}=${t}`
        },
        getCookie(e) {
            return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${e}s*=s*([^;]*).*$)|^.*$`), "$1")
        },
        redirect(e, t) {
            t && Jt.setCookie("__phoenix_flash__", t + "; max-age=60000; path=/"),
            window.location = e
        },
        localKey(e, t) {
            return `${e}-${t}`
        },
        getHashTargetEl(e) {
            let t = e.toString().substring(1);
            if (t !== "")
                return document.getElementById(t) || document.querySelector(`a[name="${t}"]`)
        }
    }
      , K = Jt
      , H = {
        byId(e) {
            return document.getElementById(e) || _(`no id found for ${e}`)
        },
        removeClass(e, t) {
            e.classList.remove(t),
            e.classList.length === 0 && e.removeAttribute("class")
        },
        all(e, t, i) {
            if (!e)
                return [];
            let r = Array.from(e.querySelectorAll(t));
            return i ? r.forEach(i) : r
        },
        childNodeLength(e) {
            let t = document.createElement("template");
            return t.innerHTML = e,
            t.content.childElementCount
        },
        isUploadInput(e) {
            return e.type === "file" && e.getAttribute(te) !== null
        },
        findUploadInputs(e) {
            return this.all(e, `input[type="file"][${te}]`)
        },
        findComponentNodeList(e, t) {
            return this.filterWithinSameLiveView(this.all(e, `[${O}="${t}"]`), e)
        },
        isPhxDestroyed(e) {
            return !!(e.id && H.private(e, "destroyed"))
        },
        markPhxChildDestroyed(e) {
            this.isPhxChild(e) && e.setAttribute(Y, ""),
            this.putPrivate(e, "destroyed", !0)
        },
        findPhxChildrenInFragment(e, t) {
            let i = document.createElement("template");
            return i.innerHTML = e,
            this.findPhxChildren(i.content, t)
        },
        isIgnored(e, t) {
            return (e.getAttribute(t) || e.getAttribute("data-phx-update")) === "ignore"
        },
        isPhxUpdate(e, t, i) {
            return e.getAttribute && i.indexOf(e.getAttribute(t)) >= 0
        },
        findPhxSticky(e) {
            return this.all(e, `[${xt}]`)
        },
        findPhxChildren(e, t) {
            return this.all(e, `${ne}[${re}="${t}"]`)
        },
        findParentCIDs(e, t) {
            let i = new Set(t);
            return t.reduce( (r, n) => {
                let s = `[${O}="${n}"] [${O}]`;
                return this.filterWithinSameLiveView(this.all(e, s), e).map(o => parseInt(o.getAttribute(O))).forEach(o => r.delete(o)),
                r
            }
            , i)
        },
        filterWithinSameLiveView(e, t) {
            return t.querySelector(ne) ? e.filter(i => this.withinSameLiveView(i, t)) : e
        },
        withinSameLiveView(e, t) {
            for (; e = e.parentNode; ) {
                if (e.isSameNode(t))
                    return !0;
                if (e.getAttribute(Y) !== null)
                    return !1
            }
        },
        private(e, t) {
            return e[M] && e[M][t]
        },
        deletePrivate(e, t) {
            e[M] && delete e[M][t]
        },
        putPrivate(e, t, i) {
            e[M] || (e[M] = {}),
            e[M][t] = i
        },
        updatePrivate(e, t, i, r) {
            let n = this.private(e, t);
            n === void 0 ? this.putPrivate(e, t, r(i)) : this.putPrivate(e, t, r(n))
        },
        copyPrivates(e, t) {
            t[M] && (e[M] = t[M])
        },
        putTitle(e) {
            let t = document.querySelector("title")
              , {prefix: i, suffix: r} = t.dataset;
            document.title = `${i || ""}${e}${r || ""}`
        },
        debounce(e, t, i, r, n, s, o, a) {
            let l = e.getAttribute(i)
              , d = e.getAttribute(n);
            l === "" && (l = r),
            d === "" && (d = s);
            let f = l || d;
            switch (f) {
            case null:
                return a();
            case "blur":
                this.once(e, "debounce-blur") && e.addEventListener("blur", () => a());
                return;
            default:
                let h = parseInt(f)
                  , p = () => d ? this.deletePrivate(e, _e) : a()
                  , g = this.incCycle(e, de, p);
                if (isNaN(h))
                    return _(`invalid throttle/debounce value: ${f}`);
                if (d) {
                    let m = !1;
                    if (t.type === "keydown") {
                        let A = this.private(e, Et);
                        this.putPrivate(e, Et, t.key),
                        m = A !== t.key
                    }
                    if (!m && this.private(e, _e))
                        return !1;
                    a(),
                    this.putPrivate(e, _e, !0),
                    setTimeout( () => {
                        o() && this.triggerCycle(e, de)
                    }
                    , h)
                } else
                    setTimeout( () => {
                        o() && this.triggerCycle(e, de, g)
                    }
                    , h);
                let y = e.form;
                y && this.once(y, "bind-debounce") && y.addEventListener("submit", () => {
                    Array.from(new FormData(y).entries(), ([m]) => {
                        let A = y.querySelector(`[name="${m}"]`);
                        this.incCycle(A, de),
                        this.deletePrivate(A, _e)
                    }
                    )
                }
                ),
                this.once(e, "bind-debounce") && e.addEventListener("blur", () => this.triggerCycle(e, de))
            }
        },
        triggerCycle(e, t, i) {
            let[r,n] = this.private(e, t);
            i || (i = r),
            i === r && (this.incCycle(e, t),
            n())
        },
        once(e, t) {
            return this.private(e, t) === !0 ? !1 : (this.putPrivate(e, t, !0),
            !0)
        },
        incCycle(e, t, i=function() {}
        ) {
            let[r] = this.private(e, t) || [0, i];
            return r++,
            this.putPrivate(e, t, [r, i]),
            r
        },
        discardError(e, t, i) {
            let r = t.getAttribute && t.getAttribute(i)
              , n = r && e.querySelector(`[id="${r}"], [name="${r}"]`);
            n && (this.private(n, $t) || this.private(n.form, Bt) || t.classList.add(kt))
        },
        showError(e, t) {
            (e.id || e.name) && this.all(e.form, `[${t}="${e.id}"], [${t}="${e.name}"]`, i => {
                this.removeClass(i, kt)
            }
            )
        },
        isPhxChild(e) {
            return e.getAttribute && e.getAttribute(re)
        },
        isPhxSticky(e) {
            return e.getAttribute && e.getAttribute(xt) !== null
        },
        firstPhxChild(e) {
            return this.isPhxChild(e) ? e : this.all(e, `[${re}]`)[0]
        },
        dispatchEvent(e, t, i={}) {
            let n = {
                bubbles: i.bubbles === void 0 ? !0 : !!i.bubbles,
                cancelable: !0,
                detail: i.detail || {}
            }
              , s = t === "click" ? new MouseEvent("click",n) : new CustomEvent(t,n);
            e.dispatchEvent(s)
        },
        cloneNode(e, t) {
            if (typeof t == "undefined")
                return e.cloneNode(!0);
            {
                let i = e.cloneNode(!1);
                return i.innerHTML = t,
                i
            }
        },
        mergeAttrs(e, t, i={}) {
            let r = i.exclude || []
              , n = i.isIgnored
              , s = t.attributes;
            for (let a = s.length - 1; a >= 0; a--) {
                let l = s[a].name;
                r.indexOf(l) < 0 && e.setAttribute(l, t.getAttribute(l))
            }
            let o = e.attributes;
            for (let a = o.length - 1; a >= 0; a--) {
                let l = o[a].name;
                n ? l.startsWith("data-") && !t.hasAttribute(l) && e.removeAttribute(l) : t.hasAttribute(l) || e.removeAttribute(l)
            }
        },
        mergeFocusedInput(e, t) {
            e instanceof HTMLSelectElement || H.mergeAttrs(e, t, {
                exclude: ["value"]
            }),
            t.readOnly ? e.setAttribute("readonly", !0) : e.removeAttribute("readonly")
        },
        hasSelectionRange(e) {
            return e.setSelectionRange && (e.type === "text" || e.type === "textarea")
        },
        restoreFocus(e, t, i) {
            if (!H.isTextualInput(e))
                return;
            let r = e.matches(":focus");
            e.readOnly && e.blur(),
            r || e.focus(),
            this.hasSelectionRange(e) && e.setSelectionRange(t, i)
        },
        isFormInput(e) {
            return /^(?:input|select|textarea)$/i.test(e.tagName) && e.type !== "button"
        },
        syncAttrsToProps(e) {
            e instanceof HTMLInputElement && Ft.indexOf(e.type.toLocaleLowerCase()) >= 0 && (e.checked = e.getAttribute("checked") !== null)
        },
        isTextualInput(e) {
            return Ki.indexOf(e.type) >= 0
        },
        isNowTriggerFormExternal(e, t) {
            return e.getAttribute && e.getAttribute(t) !== null
        },
        syncPendingRef(e, t, i) {
            let r = e.getAttribute(F);
            if (r === null)
                return !0;
            let n = e.getAttribute(ee);
            return H.isFormInput(e) || e.getAttribute(i) !== null ? (H.isUploadInput(e) && H.mergeAttrs(e, t, {
                isIgnored: !0
            }),
            H.putPrivate(e, F, t),
            !1) : (Mt.forEach(s => {
                e.classList.contains(s) && t.classList.add(s)
            }
            ),
            t.setAttribute(F, r),
            t.setAttribute(ee, n),
            !0)
        },
        cleanChildNodes(e, t) {
            if (H.isPhxUpdate(e, t, ["append", "prepend"])) {
                let i = [];
                e.childNodes.forEach(r => {
                    r.id || (r.nodeType === Node.TEXT_NODE && r.nodeValue.trim() === "" || _(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(r.outerHTML || r.nodeValue).trim()}"

`),
                    i.push(r))
                }
                ),
                i.forEach(r => r.remove())
            }
        },
        replaceRootContainer(e, t, i) {
            let r = new Set(["id", Y, pe, it, me]);
            if (e.tagName.toLowerCase() === t.toLowerCase())
                return Array.from(e.attributes).filter(n => !r.has(n.name.toLowerCase())).forEach(n => e.removeAttribute(n.name)),
                Object.keys(i).filter(n => !r.has(n.toLowerCase())).forEach(n => e.setAttribute(n, i[n])),
                e;
            {
                let n = document.createElement(t);
                return Object.keys(i).forEach(s => n.setAttribute(s, i[s])),
                r.forEach(s => n.setAttribute(s, e.getAttribute(s))),
                n.innerHTML = e.innerHTML,
                e.replaceWith(n),
                n
            }
        },
        getSticky(e, t, i) {
            let r = (H.private(e, "sticky") || []).find( ([n]) => t === n);
            if (r) {
                let[n,s,o] = r;
                return o
            } else
                return typeof i == "function" ? i() : i
        },
        deleteSticky(e, t) {
            this.updatePrivate(e, "sticky", [], i => i.filter( ([r,n]) => r !== t))
        },
        putSticky(e, t, i) {
            let r = i(e);
            this.updatePrivate(e, "sticky", [], n => {
                let s = n.findIndex( ([o]) => t === o);
                return s >= 0 ? n[s] = [t, i, r] : n.push([t, i, r]),
                n
            }
            )
        },
        applyStickyOperations(e) {
            let t = H.private(e, "sticky");
            t && t.forEach( ([i,r,n]) => this.putSticky(e, i, r))
        }
    }
      , c = H
      , qe = class {
        static isActive(e, t) {
            let i = t._phxRef === void 0
              , n = e.getAttribute(Ke).split(",").indexOf(T.genFileRef(t)) >= 0;
            return t.size > 0 && (i || n)
        }
        static isPreflighted(e, t) {
            return e.getAttribute(tt).split(",").indexOf(T.genFileRef(t)) >= 0 && this.isActive(e, t)
        }
        constructor(e, t, i) {
            this.ref = T.genFileRef(t),
            this.fileEl = e,
            this.file = t,
            this.view = i,
            this.meta = null,
            this._isCancelled = !1,
            this._isDone = !1,
            this._progress = 0,
            this._lastProgressSent = -1,
            this._onDone = function() {}
            ,
            this._onElUpdated = this.onElUpdated.bind(this),
            this.fileEl.addEventListener(Ge, this._onElUpdated)
        }
        metadata() {
            return this.meta
        }
        progress(e) {
            this._progress = Math.floor(e),
            this._progress > this._lastProgressSent && (this._progress >= 100 ? (this._progress = 100,
            this._lastProgressSent = 100,
            this._isDone = !0,
            this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
                T.untrackFile(this.fileEl, this.file),
                this._onDone()
            }
            )) : (this._lastProgressSent = this._progress,
            this.view.pushFileProgress(this.fileEl, this.ref, this._progress)))
        }
        cancel() {
            this._isCancelled = !0,
            this._isDone = !0,
            this._onDone()
        }
        isDone() {
            return this._isDone
        }
        error(e="failed") {
            this.view.pushFileProgress(this.fileEl, this.ref, {
                error: e
            }),
            T.clearFiles(this.fileEl)
        }
        onDone(e) {
            this._onDone = () => {
                this.fileEl.removeEventListener(Ge, this._onElUpdated),
                e()
            }
        }
        onElUpdated() {
            this.fileEl.getAttribute(Ke).split(",").indexOf(this.ref) === -1 && this.cancel()
        }
        toPreflightPayload() {
            return {
                last_modified: this.file.lastModified,
                name: this.file.name,
                size: this.file.size,
                type: this.file.type,
                ref: this.ref
            }
        }
        uploader(e) {
            if (this.meta.uploader) {
                let t = e[this.meta.uploader] || _(`no uploader configured for ${this.meta.uploader}`);
                return {
                    name: this.meta.uploader,
                    callback: t
                }
            } else
                return {
                    name: "channel",
                    callback: dr
                }
        }
        zipPostFlight(e) {
            this.meta = e.entries[this.ref],
            this.meta || _(`no preflight upload response returned with ref ${this.ref}`, {
                input: this.fileEl,
                response: e
            })
        }
    }
      , cr = 0
      , T = class {
        static genFileRef(e) {
            let t = e._phxRef;
            return t !== void 0 ? t : (e._phxRef = (cr++).toString(),
            e._phxRef)
        }
        static getEntryDataURL(e, t, i) {
            let r = this.activeFiles(e).find(n => this.genFileRef(n) === t);
            i(URL.createObjectURL(r))
        }
        static hasUploadsInProgress(e) {
            let t = 0;
            return c.findUploadInputs(e).forEach(i => {
                i.getAttribute(tt) !== i.getAttribute(qi) && t++
            }
            ),
            t > 0
        }
        static serializeUploads(e) {
            let t = this.activeFiles(e)
              , i = {};
            return t.forEach(r => {
                let n = {
                    path: e.name
                }
                  , s = e.getAttribute(te);
                i[s] = i[s] || [],
                n.ref = this.genFileRef(r),
                n.name = r.name || n.ref,
                n.type = r.type,
                n.size = r.size,
                i[s].push(n)
            }
            ),
            i
        }
        static clearFiles(e) {
            e.value = null,
            e.removeAttribute(te),
            c.putPrivate(e, "files", [])
        }
        static untrackFile(e, t) {
            c.putPrivate(e, "files", c.private(e, "files").filter(i => !Object.is(i, t)))
        }
        static trackFiles(e, t) {
            if (e.getAttribute("multiple") !== null) {
                let i = t.filter(r => !this.activeFiles(e).find(n => Object.is(n, r)));
                c.putPrivate(e, "files", this.activeFiles(e).concat(i)),
                e.value = null
            } else
                c.putPrivate(e, "files", t)
        }
        static activeFileInputs(e) {
            let t = c.findUploadInputs(e);
            return Array.from(t).filter(i => i.files && this.activeFiles(i).length > 0)
        }
        static activeFiles(e) {
            return (c.private(e, "files") || []).filter(t => qe.isActive(e, t))
        }
        static inputsAwaitingPreflight(e) {
            let t = c.findUploadInputs(e);
            return Array.from(t).filter(i => this.filesAwaitingPreflight(i).length > 0)
        }
        static filesAwaitingPreflight(e) {
            return this.activeFiles(e).filter(t => !qe.isPreflighted(e, t))
        }
        constructor(e, t, i) {
            this.view = t,
            this.onComplete = i,
            this._entries = Array.from(T.filesAwaitingPreflight(e) || []).map(r => new qe(e,r,t)),
            this.numEntriesInProgress = this._entries.length
        }
        entries() {
            return this._entries
        }
        initAdapterUpload(e, t, i) {
            this._entries = this._entries.map(n => (n.zipPostFlight(e),
            n.onDone( () => {
                this.numEntriesInProgress--,
                this.numEntriesInProgress === 0 && this.onComplete()
            }
            ),
            n));
            let r = this._entries.reduce( (n, s) => {
                let {name: o, callback: a} = s.uploader(i.uploaders);
                return n[o] = n[o] || {
                    callback: a,
                    entries: []
                },
                n[o].entries.push(s),
                n
            }
            , {});
            for (let n in r) {
                let {callback: s, entries: o} = r[n];
                s(o, t, e, i)
            }
        }
    }
      , ur = {
        LiveFileUpload: {
            activeRefs() {
                return this.el.getAttribute(Ke)
            },
            preflightedRefs() {
                return this.el.getAttribute(tt)
            },
            mounted() {
                this.preflightedWas = this.preflightedRefs()
            },
            updated() {
                let e = this.preflightedRefs();
                this.preflightedWas !== e && (this.preflightedWas = e,
                e === "" && this.__view.cancelSubmit(this.el.form)),
                this.activeRefs() === "" && (this.el.value = null),
                this.el.dispatchEvent(new CustomEvent(Ge))
            }
        },
        LiveImgPreview: {
            mounted() {
                this.ref = this.el.getAttribute("data-phx-entry-ref"),
                this.inputEl = document.getElementById(this.el.getAttribute(te)),
                T.getEntryDataURL(this.inputEl, this.ref, e => {
                    this.url = e,
                    this.el.src = e
                }
                )
            },
            destroyed() {
                URL.revokeObjectURL(this.url)
            }
        }
    }
      , fr = ur
      , pr = class {
        constructor(e, t, i) {
            let r = new Set
              , n = new Set([...t.children].map(o => o.id))
              , s = [];
            Array.from(e.children).forEach(o => {
                if (o.id && (r.add(o.id),
                n.has(o.id))) {
                    let a = o.previousElementSibling && o.previousElementSibling.id;
                    s.push({
                        elementId: o.id,
                        previousElementId: a
                    })
                }
            }
            ),
            this.containerId = t.id,
            this.updateType = i,
            this.elementsToModify = s,
            this.elementIdsToAdd = [...n].filter(o => !r.has(o))
        }
        perform() {
            let e = c.byId(this.containerId);
            this.elementsToModify.forEach(t => {
                t.previousElementId ? z(document.getElementById(t.previousElementId), i => {
                    z(document.getElementById(t.elementId), r => {
                        r.previousElementSibling && r.previousElementSibling.id == i.id || i.insertAdjacentElement("afterend", r)
                    }
                    )
                }
                ) : z(document.getElementById(t.elementId), i => {
                    i.previousElementSibling == null || e.insertAdjacentElement("afterbegin", i)
                }
                )
            }
            ),
            this.updateType == "prepend" && this.elementIdsToAdd.reverse().forEach(t => {
                z(document.getElementById(t), i => e.insertAdjacentElement("afterbegin", i))
            }
            )
        }
    }
      , Lt = 11;
    function gr(e, t) {
        var i = t.attributes, r, n, s, o, a;
        if (!(t.nodeType === Lt || e.nodeType === Lt)) {
            for (var l = i.length - 1; l >= 0; l--)
                r = i[l],
                n = r.name,
                s = r.namespaceURI,
                o = r.value,
                s ? (n = r.localName || n,
                a = e.getAttributeNS(s, n),
                a !== o && (r.prefix === "xmlns" && (n = r.name),
                e.setAttributeNS(s, n, o))) : (a = e.getAttribute(n),
                a !== o && e.setAttribute(n, o));
            for (var d = e.attributes, f = d.length - 1; f >= 0; f--)
                r = d[f],
                n = r.name,
                s = r.namespaceURI,
                s ? (n = r.localName || n,
                t.hasAttributeNS(s, n) || e.removeAttributeNS(s, n)) : t.hasAttribute(n) || e.removeAttribute(n)
        }
    }
    var Pe, mr = "http://www.w3.org/1999/xhtml", R = typeof document == "undefined" ? void 0 : document, vr = !!R && "content"in R.createElement("template"), br = !!R && R.createRange && "createContextualFragment"in R.createRange();
    function yr(e) {
        var t = R.createElement("template");
        return t.innerHTML = e,
        t.content.childNodes[0]
    }
    function wr(e) {
        Pe || (Pe = R.createRange(),
        Pe.selectNode(R.body));
        var t = Pe.createContextualFragment(e);
        return t.childNodes[0]
    }
    function kr(e) {
        var t = R.createElement("body");
        return t.innerHTML = e,
        t.childNodes[0]
    }
    function Sr(e) {
        return e = e.trim(),
        vr ? yr(e) : br ? wr(e) : kr(e)
    }
    function Re(e, t) {
        var i = e.nodeName, r = t.nodeName, n, s;
        return i === r ? !0 : (n = i.charCodeAt(0),
        s = r.charCodeAt(0),
        n <= 90 && s >= 97 ? i === r.toUpperCase() : s <= 90 && n >= 97 ? r === i.toUpperCase() : !1)
    }
    function xr(e, t) {
        return !t || t === mr ? R.createElement(e) : R.createElementNS(t, e)
    }
    function Ar(e, t) {
        for (var i = e.firstChild; i; ) {
            var r = i.nextSibling;
            t.appendChild(i),
            i = r
        }
        return t
    }
    function We(e, t, i) {
        e[i] !== t[i] && (e[i] = t[i],
        e[i] ? e.setAttribute(i, "") : e.removeAttribute(i))
    }
    var It = {
        OPTION: function(e, t) {
            var i = e.parentNode;
            if (i) {
                var r = i.nodeName.toUpperCase();
                r === "OPTGROUP" && (i = i.parentNode,
                r = i && i.nodeName.toUpperCase()),
                r === "SELECT" && !i.hasAttribute("multiple") && (e.hasAttribute("selected") && !t.selected && (e.setAttribute("selected", "selected"),
                e.removeAttribute("selected")),
                i.selectedIndex = -1)
            }
            We(e, t, "selected")
        },
        INPUT: function(e, t) {
            We(e, t, "checked"),
            We(e, t, "disabled"),
            e.value !== t.value && (e.value = t.value),
            t.hasAttribute("value") || e.removeAttribute("value")
        },
        TEXTAREA: function(e, t) {
            var i = t.value;
            e.value !== i && (e.value = i);
            var r = e.firstChild;
            if (r) {
                var n = r.nodeValue;
                if (n == i || !i && n == e.placeholder)
                    return;
                r.nodeValue = i
            }
        },
        SELECT: function(e, t) {
            if (!t.hasAttribute("multiple")) {
                for (var i = -1, r = 0, n = e.firstChild, s, o; n; )
                    if (o = n.nodeName && n.nodeName.toUpperCase(),
                    o === "OPTGROUP")
                        s = n,
                        n = s.firstChild;
                    else {
                        if (o === "OPTION") {
                            if (n.hasAttribute("selected")) {
                                i = r;
                                break
                            }
                            r++
                        }
                        n = n.nextSibling,
                        !n && s && (n = s.nextSibling,
                        s = null)
                    }
                e.selectedIndex = i
            }
        }
    }
      , ue = 1
      , Er = 11
      , Dt = 3
      , Ot = 8;
    function Z() {}
    function Cr(e) {
        if (e)
            return e.getAttribute && e.getAttribute("id") || e.id
    }
    function Tr(e) {
        return function(i, r, n) {
            if (n || (n = {}),
            typeof r == "string")
                if (i.nodeName === "#document" || i.nodeName === "HTML" || i.nodeName === "BODY") {
                    var s = r;
                    r = R.createElement("html"),
                    r.innerHTML = s
                } else
                    r = Sr(r);
            var o = n.getNodeKey || Cr
              , a = n.onBeforeNodeAdded || Z
              , l = n.onNodeAdded || Z
              , d = n.onBeforeElUpdated || Z
              , f = n.onElUpdated || Z
              , h = n.onBeforeNodeDiscarded || Z
              , p = n.onNodeDiscarded || Z
              , g = n.onBeforeElChildrenUpdated || Z
              , y = n.childrenOnly === !0
              , m = Object.create(null)
              , A = [];
            function C(w) {
                A.push(w)
            }
            function B(w, b) {
                if (w.nodeType === ue)
                    for (var v = w.firstChild; v; ) {
                        var k = void 0;
                        b && (k = o(v)) ? C(k) : (p(v),
                        v.firstChild && B(v, b)),
                        v = v.nextSibling
                    }
            }
            function u(w, b, v) {
                h(w) !== !1 && (b && b.removeChild(w),
                p(w),
                B(w, v))
            }
            function S(w) {
                if (w.nodeType === ue || w.nodeType === Er)
                    for (var b = w.firstChild; b; ) {
                        var v = o(b);
                        v && (m[v] = b),
                        S(b),
                        b = b.nextSibling
                    }
            }
            S(i);
            function V(w) {
                l(w);
                for (var b = w.firstChild; b; ) {
                    var v = b.nextSibling
                      , k = o(b);
                    if (k) {
                        var N = m[k];
                        N && Re(b, N) ? (b.parentNode.replaceChild(N, b),
                        L(N, b)) : V(b)
                    } else
                        V(b);
                    b = v
                }
            }
            function x(w, b, v) {
                for (; b; ) {
                    var k = b.nextSibling;
                    (v = o(b)) ? C(v) : u(b, w, !0),
                    b = k
                }
            }
            function L(w, b, v) {
                var k = o(b);
                k && delete m[k],
                !(!v && (d(w, b) === !1 || (e(w, b),
                f(w),
                g(w, b) === !1))) && (w.nodeName !== "TEXTAREA" ? Q(w, b) : It.TEXTAREA(w, b))
            }
            function Q(w, b) {
                var v = b.firstChild, k = w.firstChild, N, X, ie, ye, q;
                e: for (; v; ) {
                    for (ye = v.nextSibling,
                    N = o(v); k; ) {
                        if (ie = k.nextSibling,
                        v.isSameNode && v.isSameNode(k)) {
                            v = ye,
                            k = ie;
                            continue e
                        }
                        X = o(k);
                        var we = k.nodeType
                          , W = void 0;
                        if (we === v.nodeType && (we === ue ? (N ? N !== X && ((q = m[N]) ? ie === q ? W = !1 : (w.insertBefore(q, k),
                        X ? C(X) : u(k, w, !0),
                        k = q) : W = !1) : X && (W = !1),
                        W = W !== !1 && Re(k, v),
                        W && L(k, v)) : (we === Dt || we == Ot) && (W = !0,
                        k.nodeValue !== v.nodeValue && (k.nodeValue = v.nodeValue))),
                        W) {
                            v = ye,
                            k = ie;
                            continue e
                        }
                        X ? C(X) : u(k, w, !0),
                        k = ie
                    }
                    if (N && (q = m[N]) && Re(q, v))
                        w.appendChild(q),
                        L(q, v);
                    else {
                        var je = a(v);
                        je !== !1 && (je && (v = je),
                        v.actualize && (v = v.actualize(w.ownerDocument || R)),
                        w.appendChild(v),
                        V(v))
                    }
                    v = ye,
                    k = ie
                }
                x(w, k, X);
                var lt = It[w.nodeName];
                lt && lt(w, b)
            }
            var E = i
              , be = E.nodeType
              , at = r.nodeType;
            if (!y) {
                if (be === ue)
                    at === ue ? Re(i, r) || (p(i),
                    E = Ar(i, xr(r.nodeName, r.namespaceURI))) : E = r;
                else if (be === Dt || be === Ot) {
                    if (at === be)
                        return E.nodeValue !== r.nodeValue && (E.nodeValue = r.nodeValue),
                        E;
                    E = r
                }
            }
            if (E === r)
                p(i);
            else {
                if (r.isSameNode && r.isSameNode(E))
                    return;
                if (L(E, r, y),
                A)
                    for (var Ne = 0, _i = A.length; Ne < _i; Ne++) {
                        var He = m[A[Ne]];
                        He && u(He, He.parentNode, !1)
                    }
            }
            return !y && E !== i && i.parentNode && (E.actualize && (E = E.actualize(i.ownerDocument || R)),
            i.parentNode.replaceChild(E, i)),
            E
        }
    }
    var _r = Tr(gr)
      , Nt = _r
      , Le = class {
        static patchEl(e, t, i) {
            Nt(e, t, {
                childrenOnly: !1,
                onBeforeElUpdated: (r, n) => {
                    if (i && i.isSameNode(r) && c.isFormInput(r))
                        return c.mergeFocusedInput(r, n),
                        !1
                }
            })
        }
        constructor(e, t, i, r, n) {
            this.view = e,
            this.liveSocket = e.liveSocket,
            this.container = t,
            this.id = i,
            this.rootID = e.root.id,
            this.html = r,
            this.targetCID = n,
            this.cidPatch = G(this.targetCID),
            this.callbacks = {
                beforeadded: [],
                beforeupdated: [],
                beforephxChildAdded: [],
                afteradded: [],
                afterupdated: [],
                afterdiscarded: [],
                afterphxChildAdded: [],
                aftertransitionsDiscarded: []
            }
        }
        before(e, t) {
            this.callbacks[`before${e}`].push(t)
        }
        after(e, t) {
            this.callbacks[`after${e}`].push(t)
        }
        trackBefore(e, ...t) {
            this.callbacks[`before${e}`].forEach(i => i(...t))
        }
        trackAfter(e, ...t) {
            this.callbacks[`after${e}`].forEach(i => i(...t))
        }
        markPrunableContentForRemoval() {
            c.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", e => {
                e.setAttribute(bt, "")
            }
            )
        }
        perform() {
            let {view: e, liveSocket: t, container: i, html: r} = this
              , n = this.isCIDPatch() ? this.targetCIDContainer(r) : i;
            if (this.isCIDPatch() && !n)
                return;
            let s = t.getActiveElement()
              , {selectionStart: o, selectionEnd: a} = s && c.hasSelectionRange(s) ? s : {}
              , l = t.binding(et)
              , d = t.binding(Qe)
              , f = t.binding(Ze)
              , h = t.binding(Wi)
              , p = t.binding("remove")
              , g = []
              , y = []
              , m = []
              , A = []
              , C = null
              , B = t.time("premorph container prep", () => this.buildDiffHTML(i, r, l, n));
            return this.trackBefore("added", i),
            this.trackBefore("updated", i, i),
            t.time("morphdom", () => {
                Nt(n, B, {
                    childrenOnly: n.getAttribute(O) === null,
                    getNodeKey: u => c.isPhxDestroyed(u) ? null : u.id,
                    onBeforeNodeAdded: u => (this.trackBefore("added", u),
                    u),
                    onNodeAdded: u => {
                        u instanceof HTMLImageElement && u.srcset ? u.srcset = u.srcset : u instanceof HTMLVideoElement && u.autoplay && u.play(),
                        c.isNowTriggerFormExternal(u, h) && (C = u),
                        c.discardError(n, u, d),
                        (c.isPhxChild(u) && e.ownsElement(u) || c.isPhxSticky(u) && e.ownsElement(u.parentNode)) && this.trackAfter("phxChildAdded", u),
                        g.push(u)
                    }
                    ,
                    onNodeDiscarded: u => {
                        (c.isPhxChild(u) || c.isPhxSticky(u)) && t.destroyViewByEl(u),
                        this.trackAfter("discarded", u)
                    }
                    ,
                    onBeforeNodeDiscarded: u => u.getAttribute && u.getAttribute(bt) !== null ? !0 : u.parentNode !== null && c.isPhxUpdate(u.parentNode, l, ["append", "prepend"]) && u.id ? !1 : u.getAttribute && u.getAttribute(p) ? (A.push(u),
                    !1) : !this.skipCIDSibling(u),
                    onElUpdated: u => {
                        c.isNowTriggerFormExternal(u, h) && (C = u),
                        y.push(u)
                    }
                    ,
                    onBeforeElUpdated: (u, S) => {
                        if (c.cleanChildNodes(S, l),
                        this.skipCIDSibling(S) || c.isPhxSticky(u))
                            return !1;
                        if (c.isIgnored(u, l))
                            return this.trackBefore("updated", u, S),
                            c.mergeAttrs(u, S, {
                                isIgnored: !0
                            }),
                            y.push(u),
                            c.applyStickyOperations(u),
                            !1;
                        if (u.type === "number" && u.validity && u.validity.badInput)
                            return !1;
                        if (!c.syncPendingRef(u, S, f))
                            return c.isUploadInput(u) && (this.trackBefore("updated", u, S),
                            y.push(u)),
                            c.applyStickyOperations(u),
                            !1;
                        if (c.isPhxChild(S)) {
                            let x = u.getAttribute(Y);
                            return c.mergeAttrs(u, S, {
                                exclude: [pe]
                            }),
                            x !== "" && u.setAttribute(Y, x),
                            u.setAttribute(me, this.rootID),
                            c.applyStickyOperations(u),
                            !1
                        }
                        return c.copyPrivates(S, u),
                        c.discardError(n, S, d),
                        s && u.isSameNode(s) && c.isFormInput(u) ? (this.trackBefore("updated", u, S),
                        c.mergeFocusedInput(u, S),
                        c.syncAttrsToProps(u),
                        y.push(u),
                        c.applyStickyOperations(u),
                        !1) : (c.isPhxUpdate(S, l, ["append", "prepend"]) && m.push(new pr(u,S,S.getAttribute(l))),
                        c.syncAttrsToProps(S),
                        c.applyStickyOperations(S),
                        this.trackBefore("updated", u, S),
                        !0)
                    }
                })
            }
            ),
            t.isDebugEnabled() && ar(),
            m.length > 0 && t.time("post-morph append/prepend restoration", () => {
                m.forEach(u => u.perform())
            }
            ),
            t.silenceEvents( () => c.restoreFocus(s, o, a)),
            c.dispatchEvent(document, "phx:update"),
            g.forEach(u => this.trackAfter("added", u)),
            y.forEach(u => this.trackAfter("updated", u)),
            A.length > 0 && (t.transitionRemoves(A),
            t.requestDOMUpdate( () => {
                A.forEach(u => {
                    let S = c.firstPhxChild(u);
                    S && t.destroyViewByEl(S),
                    u.remove()
                }
                ),
                this.trackAfter("transitionsDiscarded", A)
            }
            )),
            C && (t.disconnect(),
            C.submit()),
            !0
        }
        isCIDPatch() {
            return this.cidPatch
        }
        skipCIDSibling(e) {
            return e.nodeType === Node.ELEMENT_NODE && e.getAttribute(Ye) !== null
        }
        targetCIDContainer(e) {
            if (!this.isCIDPatch())
                return;
            let[t,...i] = c.findComponentNodeList(this.container, this.targetCID);
            return i.length === 0 && c.childNodeLength(e) === 1 ? t : t && t.parentNode
        }
        buildDiffHTML(e, t, i, r) {
            let n = this.isCIDPatch()
              , s = n && r.getAttribute(O) === this.targetCID.toString();
            if (!n || s)
                return t;
            {
                let o = null
                  , a = document.createElement("template");
                o = c.cloneNode(r);
                let[l,...d] = c.findComponentNodeList(o, this.targetCID);
                return a.innerHTML = t,
                d.forEach(f => f.remove()),
                Array.from(o.childNodes).forEach(f => {
                    f.id && f.nodeType === Node.ELEMENT_NODE && f.getAttribute(O) !== this.targetCID.toString() && (f.setAttribute(Ye, ""),
                    f.innerHTML = "")
                }
                ),
                Array.from(a.content.childNodes).forEach(f => o.insertBefore(f, l)),
                l.remove(),
                o.outerHTML
            }
        }
    }
      , Ht = class {
        static extract(e) {
            let {[_t]: t, [Tt]: i, [Pt]: r} = e;
            return delete e[_t],
            delete e[Tt],
            delete e[Pt],
            {
                diff: e,
                title: r,
                reply: t || null,
                events: i || []
            }
        }
        constructor(e, t) {
            this.viewId = e,
            this.rendered = {},
            this.mergeDiff(t)
        }
        parentViewId() {
            return this.viewId
        }
        toString(e) {
            return this.recursiveToString(this.rendered, this.rendered[D], e)
        }
        recursiveToString(e, t=e[D], i) {
            i = i ? new Set(i) : null;
            let r = {
                buffer: "",
                components: t,
                onlyCids: i
            };
            return this.toOutputBuffer(e, null, r),
            r.buffer
        }
        componentCIDs(e) {
            return Object.keys(e[D] || {}).map(t => parseInt(t))
        }
        isComponentOnlyDiff(e) {
            return e[D] ? Object.keys(e).length === 1 : !1
        }
        getComponent(e, t) {
            return e[D][t]
        }
        mergeDiff(e) {
            let t = e[D]
              , i = {};
            if (delete e[D],
            this.rendered = this.mutableMerge(this.rendered, e),
            this.rendered[D] = this.rendered[D] || {},
            t) {
                let r = this.rendered[D];
                for (let n in t)
                    t[n] = this.cachedFindComponent(n, t[n], r, t, i);
                for (let n in t)
                    r[n] = t[n];
                e[D] = t
            }
        }
        cachedFindComponent(e, t, i, r, n) {
            if (n[e])
                return n[e];
            {
                let s, o, a = t[U];
                if (G(a)) {
                    let l;
                    a > 0 ? l = this.cachedFindComponent(a, r[a], i, r, n) : l = i[-a],
                    o = l[U],
                    s = this.cloneMerge(l, t),
                    s[U] = o
                } else
                    s = t[U] !== void 0 ? t : this.cloneMerge(i[e] || {}, t);
                return n[e] = s,
                s
            }
        }
        mutableMerge(e, t) {
            return t[U] !== void 0 ? t : (this.doMutableMerge(e, t),
            e)
        }
        doMutableMerge(e, t) {
            for (let i in t) {
                let r = t[i]
                  , n = e[i];
                ce(r) && r[U] === void 0 && ce(n) ? this.doMutableMerge(n, r) : e[i] = r
            }
        }
        cloneMerge(e, t) {
            let i = se(se({}, e), t);
            for (let r in i) {
                let n = t[r]
                  , s = e[r];
                ce(n) && n[U] === void 0 && ce(s) && (i[r] = this.cloneMerge(s, n))
            }
            return i
        }
        componentToString(e) {
            return this.recursiveCIDToString(this.rendered[D], e)
        }
        pruneCIDs(e) {
            e.forEach(t => delete this.rendered[D][t])
        }
        get() {
            return this.rendered
        }
        isNewFingerprint(e={}) {
            return !!e[U]
        }
        templateStatic(e, t) {
            return typeof e == "number" ? t[e] : e
        }
        toOutputBuffer(e, t, i) {
            if (e[Ct])
                return this.comprehensionToBuffer(e, t, i);
            let {[U]: r} = e;
            r = this.templateStatic(r, t),
            i.buffer += r[0];
            for (let n = 1; n < r.length; n++)
                this.dynamicToBuffer(e[n - 1], t, i),
                i.buffer += r[n]
        }
        comprehensionToBuffer(e, t, i) {
            let {[Ct]: r, [U]: n} = e;
            n = this.templateStatic(n, t);
            let s = t || e[sr];
            for (let o = 0; o < r.length; o++) {
                let a = r[o];
                i.buffer += n[0];
                for (let l = 1; l < n.length; l++)
                    this.dynamicToBuffer(a[l - 1], s, i),
                    i.buffer += n[l]
            }
        }
        dynamicToBuffer(e, t, i) {
            typeof e == "number" ? i.buffer += this.recursiveCIDToString(i.components, e, i.onlyCids) : ce(e) ? this.toOutputBuffer(e, t, i) : i.buffer += e
        }
        recursiveCIDToString(e, t, i) {
            let r = e[t] || _(`no component for CID ${t}`, e)
              , n = document.createElement("template");
            n.innerHTML = this.recursiveToString(r, e, i);
            let s = n.content
              , o = i && !i.has(t)
              , [a,l] = Array.from(s.childNodes).reduce( ([d,f], h, p) => h.nodeType === Node.ELEMENT_NODE ? h.getAttribute(O) ? [d, !0] : (h.setAttribute(O, t),
            h.id || (h.id = `${this.parentViewId()}-${t}-${p}`),
            o && (h.setAttribute(Ye, ""),
            h.innerHTML = ""),
            [!0, f]) : h.nodeValue.trim() !== "" ? (_(`only HTML element tags are allowed at the root of components.

got: "${h.nodeValue.trim()}"

within:
`, n.innerHTML.trim()),
            h.replaceWith(this.createSpan(h.nodeValue, t)),
            [!0, f]) : (h.remove(),
            [d, f]), [!1, !1]);
            return !a && !l ? (_(`expected at least one HTML element tag inside a component, but the component is empty:
`, n.innerHTML.trim()),
            this.createSpan("", t).outerHTML) : (!a && l && _("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", n.innerHTML.trim()),
            n.innerHTML)
        }
        createSpan(e, t) {
            let i = document.createElement("span");
            return i.innerText = e,
            i.setAttribute(O, t),
            i
        }
    }
      , Pr = 1
      , fe = class {
        static makeID() {
            return Pr++
        }
        static elementID(e) {
            return e.phxHookId
        }
        constructor(e, t, i) {
            this.__view = e,
            this.liveSocket = e.liveSocket,
            this.__callbacks = i,
            this.__listeners = new Set,
            this.__isDisconnected = !1,
            this.el = t,
            this.el.phxHookId = this.constructor.makeID();
            for (let r in this.__callbacks)
                this[r] = this.__callbacks[r]
        }
        __mounted() {
            this.mounted && this.mounted()
        }
        __updated() {
            this.updated && this.updated()
        }
        __beforeUpdate() {
            this.beforeUpdate && this.beforeUpdate()
        }
        __destroyed() {
            this.destroyed && this.destroyed()
        }
        __reconnected() {
            this.__isDisconnected && (this.__isDisconnected = !1,
            this.reconnected && this.reconnected())
        }
        __disconnected() {
            this.__isDisconnected = !0,
            this.disconnected && this.disconnected()
        }
        pushEvent(e, t={}, i=function() {}
        ) {
            return this.__view.pushHookEvent(null, e, t, i)
        }
        pushEventTo(e, t, i={}, r=function() {}
        ) {
            return this.__view.withinTargets(e, (n, s) => n.pushHookEvent(s, t, i, r))
        }
        handleEvent(e, t) {
            let i = (r, n) => n ? e : t(r.detail);
            return window.addEventListener(`phx:${e}`, i),
            this.__listeners.add(i),
            i
        }
        removeHandleEvent(e) {
            let t = e(null, !0);
            window.removeEventListener(`phx:${t}`, e),
            this.__listeners.delete(e)
        }
        upload(e, t) {
            return this.__view.dispatchUploads(e, t)
        }
        uploadTo(e, t, i) {
            return this.__view.withinTargets(e, r => r.dispatchUploads(t, i))
        }
        __cleanup__() {
            this.__listeners.forEach(e => this.removeHandleEvent(e))
        }
    }
      , Rr = {
        exec(e, t, i, r, n) {
            let[s,o] = n || [null, {}];
            (t.charAt(0) === "[" ? JSON.parse(t) : [[s, o]]).forEach( ([l,d]) => {
                l === s && o.data && (d.data = Object.assign(d.data || {}, o.data)),
                this.filterToEls(r, d).forEach(f => {
                    this[`exec_${l}`](e, t, i, r, f, d)
                }
                )
            }
            )
        },
        isVisible(e) {
            return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length > 0)
        },
        exec_dispatch(e, t, i, r, n, {to: s, event: o, detail: a, bubbles: l}) {
            a = a || {},
            a.dispatcher = r,
            c.dispatchEvent(n, o, {
                detail: a,
                bubbles: l
            })
        },
        exec_push(e, t, i, r, n, s) {
            if (!i.isConnected())
                return;
            let {event: o, data: a, target: l, page_loading: d, loading: f, value: h, dispatcher: p} = s
              , g = {
                loading: f,
                value: h,
                target: l,
                page_loading: !!d
            }
              , y = e === "change" && p ? p : r
              , m = l || y.getAttribute(i.binding("target")) || y;
            i.withinTargets(m, (A, C) => {
                if (e === "change") {
                    let {newCid: B, _target: u, callback: S} = s;
                    u = u || (r instanceof HTMLInputElement ? r.name : void 0),
                    u && (g._target = u),
                    A.pushInput(r, C, B, o || t, g, S)
                } else
                    e === "submit" ? A.submitForm(r, C, o || t, g) : A.pushEvent(e, r, C, o || t, a, g)
            }
            )
        },
        exec_add_class(e, t, i, r, n, {names: s, transition: o, time: a}) {
            this.addOrRemoveClasses(n, s, [], o, a, i)
        },
        exec_remove_class(e, t, i, r, n, {names: s, transition: o, time: a}) {
            this.addOrRemoveClasses(n, [], s, o, a, i)
        },
        exec_transition(e, t, i, r, n, {time: s, transition: o}) {
            let[a,l,d] = o
              , f = () => this.addOrRemoveClasses(n, a.concat(l), [])
              , h = () => this.addOrRemoveClasses(n, d, a.concat(l));
            i.transition(s, f, h)
        },
        exec_toggle(e, t, i, r, n, {display: s, ins: o, outs: a, time: l}) {
            this.toggle(e, i, n, s, o, a, l)
        },
        exec_show(e, t, i, r, n, {display: s, transition: o, time: a}) {
            this.show(e, i, n, s, o, a)
        },
        exec_hide(e, t, i, r, n, {display: s, transition: o, time: a}) {
            this.hide(e, i, n, s, o, a)
        },
        exec_set_attr(e, t, i, r, n, {attr: [s,o]}) {
            this.setOrRemoveAttrs(n, [[s, o]], [])
        },
        exec_remove_attr(e, t, i, r, n, {attr: s}) {
            this.setOrRemoveAttrs(n, [], [s])
        },
        show(e, t, i, r, n, s) {
            this.isVisible(i) || this.toggle(e, t, i, r, n, null, s)
        },
        hide(e, t, i, r, n, s) {
            this.isVisible(i) && this.toggle(e, t, i, r, null, n, s)
        },
        toggle(e, t, i, r, n, s, o) {
            let[a,l,d] = n || [[], [], []]
              , [f,h,p] = s || [[], [], []];
            if (a.length > 0 || f.length > 0)
                if (this.isVisible(i)) {
                    let g = () => {
                        this.addOrRemoveClasses(i, h, a.concat(l).concat(d)),
                        window.requestAnimationFrame( () => {
                            this.addOrRemoveClasses(i, f, []),
                            window.requestAnimationFrame( () => this.addOrRemoveClasses(i, p, h))
                        }
                        )
                    }
                    ;
                    i.dispatchEvent(new Event("phx:hide-start")),
                    t.transition(o, g, () => {
                        this.addOrRemoveClasses(i, [], f.concat(p)),
                        c.putSticky(i, "toggle", y => y.style.display = "none"),
                        i.dispatchEvent(new Event("phx:hide-end"))
                    }
                    )
                } else {
                    if (e === "remove")
                        return;
                    let g = () => {
                        this.addOrRemoveClasses(i, l, f.concat(h).concat(p)),
                        c.putSticky(i, "toggle", y => y.style.display = r || "block"),
                        window.requestAnimationFrame( () => {
                            this.addOrRemoveClasses(i, a, []),
                            window.requestAnimationFrame( () => this.addOrRemoveClasses(i, d, l))
                        }
                        )
                    }
                    ;
                    i.dispatchEvent(new Event("phx:show-start")),
                    t.transition(o, g, () => {
                        this.addOrRemoveClasses(i, [], a.concat(d)),
                        i.dispatchEvent(new Event("phx:show-end"))
                    }
                    )
                }
            else
                this.isVisible(i) ? window.requestAnimationFrame( () => {
                    i.dispatchEvent(new Event("phx:hide-start")),
                    c.putSticky(i, "toggle", g => g.style.display = "none"),
                    i.dispatchEvent(new Event("phx:hide-end"))
                }
                ) : window.requestAnimationFrame( () => {
                    i.dispatchEvent(new Event("phx:show-start")),
                    c.putSticky(i, "toggle", g => g.style.display = r || "block"),
                    i.dispatchEvent(new Event("phx:show-end"))
                }
                )
        },
        addOrRemoveClasses(e, t, i, r, n, s) {
            let[o,a,l] = r || [[], [], []];
            if (o.length > 0) {
                let d = () => this.addOrRemoveClasses(e, a.concat(o), [])
                  , f = () => this.addOrRemoveClasses(e, t.concat(l), i.concat(o).concat(a));
                return s.transition(n, d, f)
            }
            window.requestAnimationFrame( () => {
                let[d,f] = c.getSticky(e, "classes", [[], []])
                  , h = t.filter(m => d.indexOf(m) < 0 && !e.classList.contains(m))
                  , p = i.filter(m => f.indexOf(m) < 0 && e.classList.contains(m))
                  , g = d.filter(m => i.indexOf(m) < 0).concat(h)
                  , y = f.filter(m => t.indexOf(m) < 0).concat(p);
                c.putSticky(e, "classes", m => (m.classList.remove(...y),
                m.classList.add(...g),
                [g, y]))
            }
            )
        },
        setOrRemoveAttrs(e, t, i) {
            let[r,n] = c.getSticky(e, "attrs", [[], []])
              , s = t.map( ([l,d]) => l).concat(i)
              , o = r.filter( ([l,d]) => !s.includes(l)).concat(t)
              , a = n.filter(l => !s.includes(l)).concat(i);
            c.putSticky(e, "attrs", l => (a.forEach(d => l.removeAttribute(d)),
            o.forEach( ([d,f]) => l.setAttribute(d, f)),
            [o, a]))
        },
        hasAllClasses(e, t) {
            return t.every(i => e.classList.contains(i))
        },
        isToggledOut(e, t) {
            return !this.isVisible(e) || this.hasAllClasses(e, t)
        },
        filterToEls(e, {to: t}) {
            return t ? c.all(document, t) : [e]
        }
    }
      , $ = Rr
      , Ie = (e, t, i=[]) => {
        let r = new FormData(e)
          , n = [];
        r.forEach( (o, a, l) => {
            o instanceof File && n.push(a)
        }
        ),
        n.forEach(o => r.delete(o));
        let s = new URLSearchParams;
        for (let[o,a] of r.entries())
            (i.length === 0 || i.indexOf(o) >= 0) && s.append(o, a);
        for (let o in t)
            s.append(o, t[o]);
        return s.toString()
    }
      , zt = class {
        constructor(e, t, i, r) {
            this.liveSocket = t,
            this.flash = r,
            this.parent = i,
            this.root = i ? i.root : this,
            this.el = e,
            this.id = this.el.id,
            this.ref = 0,
            this.childJoins = 0,
            this.loaderTimer = null,
            this.pendingDiffs = [],
            this.pruningCIDs = [],
            this.redirect = !1,
            this.href = null,
            this.joinCount = this.parent ? this.parent.joinCount - 1 : 0,
            this.joinPending = !0,
            this.destroyed = !1,
            this.joinCallback = function(n) {
                n && n()
            }
            ,
            this.stopCallback = function() {}
            ,
            this.pendingJoinOps = this.parent ? null : [],
            this.viewHooks = {},
            this.uploaders = {},
            this.formSubmits = [],
            this.children = this.parent ? null : {},
            this.root.children[this.id] = {},
            this.channel = this.liveSocket.channel(`lv:${this.id}`, () => ({
                redirect: this.redirect ? this.href : void 0,
                url: this.redirect ? void 0 : this.href || void 0,
                params: this.connectParams(),
                session: this.getSession(),
                static: this.getStatic(),
                flash: this.flash
            })),
            this.showLoader(this.liveSocket.loaderTimeout),
            this.bindChannel()
        }
        setHref(e) {
            this.href = e
        }
        setRedirect(e) {
            this.redirect = !0,
            this.href = e
        }
        isMain() {
            return this.el.hasAttribute(it)
        }
        connectParams() {
            let e = this.liveSocket.params(this.el)
              , t = c.all(document, `[${this.binding(Vi)}]`).map(i => i.src || i.href).filter(i => typeof i == "string");
            return t.length > 0 && (e._track_static = t),
            e._mounts = this.joinCount,
            e
        }
        isConnected() {
            return this.channel.canPush()
        }
        getSession() {
            return this.el.getAttribute(Y)
        }
        getStatic() {
            let e = this.el.getAttribute(pe);
            return e === "" ? null : e
        }
        destroy(e=function() {}
        ) {
            this.destroyAllChildren(),
            this.destroyed = !0,
            delete this.root.children[this.id],
            this.parent && delete this.root.children[this.parent.id][this.id],
            clearTimeout(this.loaderTimer);
            let t = () => {
                e();
                for (let i in this.viewHooks)
                    this.destroyHook(this.viewHooks[i])
            }
            ;
            c.markPhxChildDestroyed(this.el),
            this.log("destroyed", () => ["the child has been removed from the parent"]),
            this.channel.leave().receive("ok", t).receive("error", t).receive("timeout", t)
        }
        setContainerClasses(...e) {
            this.el.classList.remove(wt, Be, St),
            this.el.classList.add(...e)
        }
        showLoader(e) {
            if (clearTimeout(this.loaderTimer),
            e)
                this.loaderTimer = setTimeout( () => this.showLoader(), e);
            else {
                for (let t in this.viewHooks)
                    this.viewHooks[t].__disconnected();
                this.setContainerClasses(Be)
            }
        }
        hideLoader() {
            clearTimeout(this.loaderTimer),
            this.setContainerClasses(wt)
        }
        triggerReconnected() {
            for (let e in this.viewHooks)
                this.viewHooks[e].__reconnected()
        }
        log(e, t) {
            this.liveSocket.log(this, e, t)
        }
        transition(e, t, i=function() {}
        ) {
            this.liveSocket.transition(e, t, i)
        }
        withinTargets(e, t) {
            if (e instanceof HTMLElement || e instanceof SVGElement)
                return this.liveSocket.owner(e, i => t(i, e));
            if (G(e))
                c.findComponentNodeList(this.el, e).length === 0 ? _(`no component found matching phx-target of ${e}`) : t(this, parseInt(e));
            else {
                let i = Array.from(document.querySelectorAll(e));
                i.length === 0 && _(`nothing found matching the phx-target selector "${e}"`),
                i.forEach(r => this.liveSocket.owner(r, n => t(n, r)))
            }
        }
        applyDiff(e, t, i) {
            this.log(e, () => ["", De(t)]);
            let {diff: r, reply: n, events: s, title: o} = Ht.extract(t);
            return o && c.putTitle(o),
            i({
                diff: r,
                reply: n,
                events: s
            }),
            n
        }
        onJoin(e) {
            let {rendered: t, container: i} = e;
            if (i) {
                let[r,n] = i;
                this.el = c.replaceRootContainer(this.el, r, n)
            }
            this.childJoins = 0,
            this.joinPending = !0,
            this.flash = null,
            K.dropLocal(this.liveSocket.localStorage, window.location.pathname, jt),
            this.applyDiff("mount", t, ({diff: r, events: n}) => {
                this.rendered = new Ht(this.id,r);
                let s = this.renderContainer(null, "join");
                this.dropPendingRefs();
                let o = this.formsForRecovery(s);
                this.joinCount++,
                o.length > 0 ? o.forEach( ([a,l,d], f) => {
                    this.pushFormRecovery(a, d, h => {
                        f === o.length - 1 && this.onJoinComplete(h, s, n)
                    }
                    )
                }
                ) : this.onJoinComplete(e, s, n)
            }
            )
        }
        dropPendingRefs() {
            c.all(document, `[${ee}="${this.id}"][${F}]`, e => {
                e.removeAttribute(F),
                e.removeAttribute(ee)
            }
            )
        }
        onJoinComplete({live_patch: e}, t, i) {
            if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending())
                return this.applyJoinPatch(e, t, i);
            c.findPhxChildrenInFragment(t, this.id).filter(n => {
                let s = n.id && this.el.querySelector(`[id="${n.id}"]`)
                  , o = s && s.getAttribute(pe);
                return o && n.setAttribute(pe, o),
                this.joinChild(n)
            }
            ).length === 0 ? this.parent ? (this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(e, t, i)]),
            this.parent.ackJoin(this)) : (this.onAllChildJoinsComplete(),
            this.applyJoinPatch(e, t, i)) : this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(e, t, i)])
        }
        attachTrueDocEl() {
            this.el = c.byId(this.id),
            this.el.setAttribute(me, this.root.id)
        }
        applyJoinPatch(e, t, i) {
            this.attachTrueDocEl();
            let r = new Le(this,this.el,this.id,t,null);
            if (r.markPrunableContentForRemoval(),
            this.performPatch(r, !1),
            this.joinNewChildren(),
            c.all(this.el, `[${this.binding(he)}], [data-phx-${he}]`, n => {
                let s = this.addHook(n);
                s && s.__mounted()
            }
            ),
            this.joinPending = !1,
            this.liveSocket.dispatchEvents(i),
            this.applyPendingUpdates(),
            e) {
                let {kind: n, to: s} = e;
                this.liveSocket.historyPatch(s, n)
            }
            this.hideLoader(),
            this.joinCount > 1 && this.triggerReconnected(),
            this.stopCallback()
        }
        triggerBeforeUpdateHook(e, t) {
            this.liveSocket.triggerDOM("onBeforeElUpdated", [e, t]);
            let i = this.getHook(e)
              , r = i && c.isIgnored(e, this.binding(et));
            if (i && !e.isEqualNode(t) && !(r && hr(e.dataset, t.dataset)))
                return i.__beforeUpdate(),
                i
        }
        performPatch(e, t) {
            let i = []
              , r = !1
              , n = new Set;
            return e.after("added", s => {
                this.liveSocket.triggerDOM("onNodeAdded", [s]);
                let o = this.addHook(s);
                o && o.__mounted()
            }
            ),
            e.after("phxChildAdded", s => {
                c.isPhxSticky(s) ? this.liveSocket.joinRootViews() : r = !0
            }
            ),
            e.before("updated", (s, o) => {
                this.triggerBeforeUpdateHook(s, o) && n.add(s.id)
            }
            ),
            e.after("updated", s => {
                n.has(s.id) && this.getHook(s).__updated()
            }
            ),
            e.after("discarded", s => {
                s.nodeType === Node.ELEMENT_NODE && i.push(s)
            }
            ),
            e.after("transitionsDiscarded", s => this.afterElementsRemoved(s, t)),
            e.perform(),
            this.afterElementsRemoved(i, t),
            r
        }
        afterElementsRemoved(e, t) {
            let i = [];
            e.forEach(r => {
                let n = c.all(r, `[${O}]`)
                  , s = c.all(r, `[${this.binding(he)}]`);
                n.concat(r).forEach(o => {
                    let a = this.componentID(o);
                    G(a) && i.indexOf(a) === -1 && i.push(a)
                }
                ),
                s.concat(r).forEach(o => {
                    let a = this.getHook(o);
                    a && this.destroyHook(a)
                }
                )
            }
            ),
            t && this.maybePushComponentsDestroyed(i)
        }
        joinNewChildren() {
            c.findPhxChildren(this.el, this.id).forEach(e => this.joinChild(e))
        }
        getChildById(e) {
            return this.root.children[this.id][e]
        }
        getDescendentByEl(e) {
            return e.id === this.id ? this : this.children[e.getAttribute(re)][e.id]
        }
        destroyDescendent(e) {
            for (let t in this.root.children)
                for (let i in this.root.children[t])
                    if (i === e)
                        return this.root.children[t][i].destroy()
        }
        joinChild(e) {
            if (!this.getChildById(e.id)) {
                let i = new zt(e,this.liveSocket,this);
                return this.root.children[this.id][i.id] = i,
                i.join(),
                this.childJoins++,
                !0
            }
        }
        isJoinPending() {
            return this.joinPending
        }
        ackJoin(e) {
            this.childJoins--,
            this.childJoins === 0 && (this.parent ? this.parent.ackJoin(this) : this.onAllChildJoinsComplete())
        }
        onAllChildJoinsComplete() {
            this.joinCallback( () => {
                this.pendingJoinOps.forEach( ([e,t]) => {
                    e.isDestroyed() || t()
                }
                ),
                this.pendingJoinOps = []
            }
            )
        }
        update(e, t) {
            if (this.isJoinPending() || this.liveSocket.hasPendingLink() && !c.isPhxSticky(this.el))
                return this.pendingDiffs.push({
                    diff: e,
                    events: t
                });
            this.rendered.mergeDiff(e);
            let i = !1;
            this.rendered.isComponentOnlyDiff(e) ? this.liveSocket.time("component patch complete", () => {
                c.findParentCIDs(this.el, this.rendered.componentCIDs(e)).forEach(n => {
                    this.componentPatch(this.rendered.getComponent(e, n), n) && (i = !0)
                }
                )
            }
            ) : Rt(e) || this.liveSocket.time("full patch complete", () => {
                let r = this.renderContainer(e, "update")
                  , n = new Le(this,this.el,this.id,r,null);
                i = this.performPatch(n, !0)
            }
            ),
            this.liveSocket.dispatchEvents(t),
            i && this.joinNewChildren()
        }
        renderContainer(e, t) {
            return this.liveSocket.time(`toString diff (${t})`, () => {
                let i = this.el.tagName
                  , r = e ? this.rendered.componentCIDs(e).concat(this.pruningCIDs) : null
                  , n = this.rendered.toString(r);
                return `<${i}>${n}</${i}>`
            }
            )
        }
        componentPatch(e, t) {
            if (Rt(e))
                return !1;
            let i = this.rendered.componentToString(t)
              , r = new Le(this,this.el,this.id,i,t);
            return this.performPatch(r, !0)
        }
        getHook(e) {
            return this.viewHooks[fe.elementID(e)]
        }
        addHook(e) {
            if (fe.elementID(e) || !e.getAttribute)
                return;
            let t = e.getAttribute(`data-phx-${he}`) || e.getAttribute(this.binding(he));
            if (t && !this.ownsElement(e))
                return;
            let i = this.liveSocket.getHookCallbacks(t);
            if (i) {
                e.id || _(`no DOM ID for hook "${t}". Hooks require a unique ID on each element.`, e);
                let r = new fe(this,e,i);
                return this.viewHooks[fe.elementID(r.el)] = r,
                r
            } else
                t !== null && _(`unknown hook found for "${t}"`, e)
        }
        destroyHook(e) {
            e.__destroyed(),
            e.__cleanup__(),
            delete this.viewHooks[fe.elementID(e.el)]
        }
        applyPendingUpdates() {
            this.pendingDiffs.forEach( ({diff: e, events: t}) => this.update(e, t)),
            this.pendingDiffs = []
        }
        onChannel(e, t) {
            this.liveSocket.onChannel(this.channel, e, i => {
                this.isJoinPending() ? this.root.pendingJoinOps.push([this, () => t(i)]) : this.liveSocket.requestDOMUpdate( () => t(i))
            }
            )
        }
        bindChannel() {
            this.liveSocket.onChannel(this.channel, "diff", e => {
                this.liveSocket.requestDOMUpdate( () => {
                    this.applyDiff("update", e, ({diff: t, events: i}) => this.update(t, i))
                }
                )
            }
            ),
            this.onChannel("redirect", ({to: e, flash: t}) => this.onRedirect({
                to: e,
                flash: t
            })),
            this.onChannel("live_patch", e => this.onLivePatch(e)),
            this.onChannel("live_redirect", e => this.onLiveRedirect(e)),
            this.channel.onError(e => this.onError(e)),
            this.channel.onClose(e => this.onClose(e))
        }
        destroyAllChildren() {
            for (let e in this.root.children[this.id])
                this.getChildById(e).destroy()
        }
        onLiveRedirect(e) {
            let {to: t, kind: i, flash: r} = e
              , n = this.expandURL(t);
            this.liveSocket.historyRedirect(n, i, r)
        }
        onLivePatch(e) {
            let {to: t, kind: i} = e;
            this.href = this.expandURL(t),
            this.liveSocket.historyPatch(t, i)
        }
        expandURL(e) {
            return e.startsWith("/") ? `${window.location.protocol}//${window.location.host}${e}` : e
        }
        onRedirect({to: e, flash: t}) {
            this.liveSocket.redirect(e, t)
        }
        isDestroyed() {
            return this.destroyed
        }
        join(e) {
            this.isMain() && (this.stopCallback = this.liveSocket.withPageLoading({
                to: this.href,
                kind: "initial"
            })),
            this.joinCallback = t => {
                t = t || function() {}
                ,
                e ? e(this.joinCount, t) : t()
            }
            ,
            this.liveSocket.wrapPush(this, {
                timeout: !1
            }, () => this.channel.join().receive("ok", t => {
                this.isDestroyed() || this.liveSocket.requestDOMUpdate( () => this.onJoin(t))
            }
            ).receive("error", t => !this.isDestroyed() && this.onJoinError(t)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({
                reason: "timeout"
            })))
        }
        onJoinError(e) {
            if (e.reason === "unauthorized" || e.reason === "stale")
                return this.log("error", () => ["unauthorized live_redirect. Falling back to page request", e]),
                this.onRedirect({
                    to: this.href
                });
            if ((e.redirect || e.live_redirect) && (this.joinPending = !1,
            this.channel.leave()),
            e.redirect)
                return this.onRedirect(e.redirect);
            if (e.live_redirect)
                return this.onLiveRedirect(e.live_redirect);
            this.log("error", () => ["unable to join", e]),
            this.liveSocket.isConnected() && this.liveSocket.reloadWithJitter(this)
        }
        onClose(e) {
            if (!this.isDestroyed()) {
                if (this.liveSocket.hasPendingLink() && e !== "leave")
                    return this.liveSocket.reloadWithJitter(this);
                this.destroyAllChildren(),
                this.liveSocket.dropActiveElement(this),
                document.activeElement && document.activeElement.blur(),
                this.liveSocket.isUnloaded() && this.showLoader(tr)
            }
        }
        onError(e) {
            this.onClose(e),
            this.liveSocket.isConnected() && this.log("error", () => ["view crashed", e]),
            this.liveSocket.isUnloaded() || this.displayError()
        }
        displayError() {
            this.isMain() && c.dispatchEvent(window, "phx:page-loading-start", {
                detail: {
                    to: this.href,
                    kind: "error"
                }
            }),
            this.showLoader(),
            this.setContainerClasses(Be, St)
        }
        pushWithReply(e, t, i, r=function() {}
        ) {
            if (!this.isConnected())
                return;
            let[n,[s],o] = e ? e() : [null, [], {}]
              , a = function() {};
            return (o.page_loading || s && s.getAttribute(this.binding(yt)) !== null) && (a = this.liveSocket.withPageLoading({
                kind: "element",
                target: s
            })),
            typeof i.cid != "number" && delete i.cid,
            this.liveSocket.wrapPush(this, {
                timeout: !0
            }, () => this.channel.push(t, i, rr).receive("ok", l => {
                n !== null && this.undoRefs(n);
                let d = f => {
                    l.redirect && this.onRedirect(l.redirect),
                    l.live_patch && this.onLivePatch(l.live_patch),
                    l.live_redirect && this.onLiveRedirect(l.live_redirect),
                    a(),
                    r(l, f)
                }
                ;
                l.diff ? this.liveSocket.requestDOMUpdate( () => {
                    let f = this.applyDiff("update", l.diff, ({diff: h, events: p}) => {
                        this.update(h, p)
                    }
                    );
                    d(f)
                }
                ) : d(null)
            }
            ))
        }
        undoRefs(e) {
            c.all(document, `[${ee}="${this.id}"][${F}="${e}"]`, t => {
                let i = t.getAttribute(Ee);
                t.removeAttribute(F),
                t.removeAttribute(ee),
                t.getAttribute(Je) !== null && (t.readOnly = !1,
                t.removeAttribute(Je)),
                i !== null && (t.disabled = i === "true",
                t.removeAttribute(Ee)),
                Mt.forEach(s => c.removeClass(t, s));
                let r = t.getAttribute(Ce);
                r !== null && (t.innerText = r,
                t.removeAttribute(Ce));
                let n = c.private(t, F);
                if (n) {
                    let s = this.triggerBeforeUpdateHook(t, n);
                    Le.patchEl(t, n, this.liveSocket.getActiveElement()),
                    s && s.__updated(),
                    c.deletePrivate(t, F)
                }
            }
            )
        }
        putRef(e, t, i={}) {
            let r = this.ref++
              , n = this.binding(Ze);
            return i.loading && (e = e.concat(c.all(document, i.loading))),
            e.forEach(s => {
                s.classList.add(`phx-${t}-loading`),
                s.setAttribute(F, r),
                s.setAttribute(ee, this.el.id);
                let o = s.getAttribute(n);
                o !== null && (s.getAttribute(Ce) || s.setAttribute(Ce, s.innerText),
                o !== "" && (s.innerText = o),
                s.setAttribute("disabled", ""))
            }
            ),
            [r, e, i]
        }
        componentID(e) {
            let t = e.getAttribute && e.getAttribute(O);
            return t ? parseInt(t) : null
        }
        targetComponentID(e, t, i={}) {
            if (G(t))
                return t;
            let r = e.getAttribute(this.binding("target"));
            return G(r) ? parseInt(r) : t && (r !== null || i.target) ? this.closestComponentID(t) : null
        }
        closestComponentID(e) {
            return G(e) ? e : e ? z(e.closest(`[${O}]`), t => this.ownsElement(t) && this.componentID(t)) : null
        }
        pushHookEvent(e, t, i, r) {
            if (!this.isConnected())
                return this.log("hook", () => ["unable to push hook event. LiveView not connected", t, i]),
                !1;
            let[n,s,o] = this.putRef([], "hook");
            return this.pushWithReply( () => [n, s, o], "event", {
                type: "hook",
                event: t,
                value: i,
                cid: this.closestComponentID(e)
            }, (a, l) => r(l, n)),
            n
        }
        extractMeta(e, t, i) {
            let r = this.binding("value-");
            for (let n = 0; n < e.attributes.length; n++) {
                t || (t = {});
                let s = e.attributes[n].name;
                s.startsWith(r) && (t[s.replace(r, "")] = e.getAttribute(s))
            }
            if (e.value !== void 0 && (t || (t = {}),
            t.value = e.value,
            e.tagName === "INPUT" && Ft.indexOf(e.type) >= 0 && !e.checked && delete t.value),
            i) {
                t || (t = {});
                for (let n in i)
                    t[n] = i[n]
            }
            return t
        }
        pushEvent(e, t, i, r, n, s={}) {
            this.pushWithReply( () => this.putRef([t], e, s), "event", {
                type: e,
                event: r,
                value: this.extractMeta(t, n, s.value),
                cid: this.targetComponentID(t, i, s)
            })
        }
        pushFileProgress(e, t, i, r=function() {}
        ) {
            this.liveSocket.withinOwners(e.form, (n, s) => {
                n.pushWithReply(null, "progress", {
                    event: e.getAttribute(n.binding(Zi)),
                    ref: e.getAttribute(te),
                    entry_ref: t,
                    progress: i,
                    cid: n.targetComponentID(e.form, s)
                }, r)
            }
            )
        }
        pushInput(e, t, i, r, n, s) {
            let o, a = G(i) ? i : this.targetComponentID(e.form, t), l = () => this.putRef([e, e.form], "change", n), d;
            e.getAttribute(this.binding("change")) ? d = Ie(e.form, {
                _target: n._target
            }, [e.name]) : d = Ie(e.form, {
                _target: n._target
            }),
            c.isUploadInput(e) && e.files && e.files.length > 0 && T.trackFiles(e, Array.from(e.files)),
            o = T.serializeUploads(e);
            let f = {
                type: "form",
                event: r,
                value: d,
                uploads: o,
                cid: a
            };
            this.pushWithReply(l, "event", f, h => {
                if (c.showError(e, this.liveSocket.binding(Qe)),
                c.isUploadInput(e) && e.getAttribute("data-phx-auto-upload") !== null) {
                    if (T.filesAwaitingPreflight(e).length > 0) {
                        let[p,g] = l();
                        this.uploadFiles(e.form, t, p, a, y => {
                            s && s(h),
                            this.triggerAwaitingSubmit(e.form)
                        }
                        )
                    }
                } else
                    s && s(h)
            }
            )
        }
        triggerAwaitingSubmit(e) {
            let t = this.getScheduledSubmit(e);
            if (t) {
                let[i,r,n,s] = t;
                this.cancelSubmit(e),
                s()
            }
        }
        getScheduledSubmit(e) {
            return this.formSubmits.find( ([t,i,r,n]) => t.isSameNode(e))
        }
        scheduleSubmit(e, t, i, r) {
            if (this.getScheduledSubmit(e))
                return !0;
            this.formSubmits.push([e, t, i, r])
        }
        cancelSubmit(e) {
            this.formSubmits = this.formSubmits.filter( ([t,i,r]) => t.isSameNode(e) ? (this.undoRefs(i),
            !1) : !0)
        }
        pushFormSubmit(e, t, i, r, n) {
            let s = h => !(ge(h, `${this.binding(et)}=ignore`, h.form) || ge(h, "data-phx-update=ignore", h.form))
              , o = h => h.hasAttribute(this.binding(Ze))
              , a = h => h.tagName == "BUTTON"
              , l = h => ["INPUT", "TEXTAREA", "SELECT"].includes(h.tagName)
              , d = () => {
                let h = Array.from(e.elements)
                  , p = h.filter(o)
                  , g = h.filter(a).filter(s)
                  , y = h.filter(l).filter(s);
                return g.forEach(m => {
                    m.setAttribute(Ee, m.disabled),
                    m.disabled = !0
                }
                ),
                y.forEach(m => {
                    m.setAttribute(Je, m.readOnly),
                    m.readOnly = !0,
                    m.files && (m.setAttribute(Ee, m.disabled),
                    m.disabled = !0)
                }
                ),
                e.setAttribute(this.binding(yt), ""),
                this.putRef([e].concat(p).concat(g).concat(y), "submit", r)
            }
              , f = this.targetComponentID(e, t);
            if (T.hasUploadsInProgress(e)) {
                let[h,p] = d()
                  , g = () => this.pushFormSubmit(e, t, i, r, n);
                return this.scheduleSubmit(e, h, r, g)
            } else if (T.inputsAwaitingPreflight(e).length > 0) {
                let[h,p] = d()
                  , g = () => [h, p, r];
                this.uploadFiles(e, t, h, f, y => {
                    let m = Ie(e, {});
                    this.pushWithReply(g, "event", {
                        type: "form",
                        event: i,
                        value: m,
                        cid: f
                    }, n)
                }
                )
            } else {
                let h = Ie(e, {});
                this.pushWithReply(d, "event", {
                    type: "form",
                    event: i,
                    value: h,
                    cid: f
                }, n)
            }
        }
        uploadFiles(e, t, i, r, n) {
            let s = this.joinCount
              , o = T.activeFileInputs(e)
              , a = o.length;
            o.forEach(l => {
                let d = new T(l,this, () => {
                    a--,
                    a === 0 && n()
                }
                );
                this.uploaders[l] = d;
                let f = d.entries().map(p => p.toPreflightPayload())
                  , h = {
                    ref: l.getAttribute(te),
                    entries: f,
                    cid: this.targetComponentID(l.form, t)
                };
                this.log("upload", () => ["sending preflight request", h]),
                this.pushWithReply(null, "allow_upload", h, p => {
                    if (this.log("upload", () => ["got preflight response", p]),
                    p.error) {
                        this.undoRefs(i);
                        let[g,y] = p.error;
                        this.log("upload", () => [`error for entry ${g}`, y])
                    } else {
                        let g = y => {
                            this.channel.onError( () => {
                                this.joinCount === s && y()
                            }
                            )
                        }
                        ;
                        d.initAdapterUpload(p, g, this.liveSocket)
                    }
                }
                )
            }
            )
        }
        dispatchUploads(e, t) {
            let i = c.findUploadInputs(this.el).filter(r => r.name === e);
            i.length === 0 ? _(`no live file inputs found matching the name "${e}"`) : i.length > 1 ? _(`duplicate live file inputs found matching the name "${e}"`) : c.dispatchEvent(i[0], Ut, {
                detail: {
                    files: t
                }
            })
        }
        pushFormRecovery(e, t, i) {
            this.liveSocket.withinOwners(e, (r, n) => {
                let s = e.elements[0]
                  , o = e.getAttribute(this.binding(At)) || e.getAttribute(this.binding("change"));
                $.exec("change", o, r, s, ["push", {
                    _target: s.name,
                    newCid: t,
                    callback: i
                }])
            }
            )
        }
        pushLinkPatch(e, t, i) {
            let r = this.liveSocket.setPendingLink(e)
              , n = t ? () => this.putRef([t], "click") : null
              , s = () => this.liveSocket.redirect(window.location.href)
              , o = this.pushWithReply(n, "live_patch", {
                url: e
            }, a => {
                this.liveSocket.requestDOMUpdate( () => {
                    a.link_redirect ? this.liveSocket.replaceMain(e, null, i, r) : (this.liveSocket.commitPendingLink(r) && (this.href = e),
                    this.applyPendingUpdates(),
                    i && i(r))
                }
                )
            }
            );
            o ? o.receive("timeout", s) : s()
        }
        formsForRecovery(e) {
            if (this.joinCount === 0)
                return [];
            let t = this.binding("change")
              , i = document.createElement("template");
            return i.innerHTML = e,
            c.all(this.el, `form[${t}]`).filter(r => r.id && this.ownsElement(r)).filter(r => r.elements.length > 0).filter(r => r.getAttribute(this.binding(At)) !== "ignore").map(r => {
                let n = i.content.querySelector(`form[id="${r.id}"][${t}="${r.getAttribute(t)}"]`);
                return n ? [r, n, this.targetComponentID(n)] : [r, null, null]
            }
            ).filter( ([r,n,s]) => n)
        }
        maybePushComponentsDestroyed(e) {
            let t = e.filter(i => c.findComponentNodeList(this.el, i).length === 0);
            t.length > 0 && (this.pruningCIDs.push(...t),
            this.pushWithReply(null, "cids_will_destroy", {
                cids: t
            }, () => {
                this.pruningCIDs = this.pruningCIDs.filter(r => t.indexOf(r) !== -1);
                let i = t.filter(r => c.findComponentNodeList(this.el, r).length === 0);
                i.length > 0 && this.pushWithReply(null, "cids_destroyed", {
                    cids: i
                }, r => {
                    this.rendered.pruneCIDs(r.cids)
                }
                )
            }
            ))
        }
        ownsElement(e) {
            return e.getAttribute(re) === this.id || z(e.closest(ne), t => t.id) === this.id
        }
        submitForm(e, t, i, r={}) {
            c.putPrivate(e, Bt, !0);
            let n = this.liveSocket.binding(Qe)
              , s = Array.from(e.elements);
            this.liveSocket.blurActiveElement(this),
            this.pushFormSubmit(e, t, i, r, () => {
                s.forEach(o => c.showError(o, n)),
                this.liveSocket.restorePreviouslyActiveFocus()
            }
            )
        }
        binding(e) {
            return this.liveSocket.binding(e)
        }
    }
      , Vt = class {
        constructor(e, t, i={}) {
            if (this.unloaded = !1,
            !t || t.constructor.name === "Object")
                throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
            this.socket = new t(e,i),
            this.bindingPrefix = i.bindingPrefix || ir,
            this.opts = i,
            this.params = Xe(i.params || {}),
            this.viewLogger = i.viewLogger,
            this.metadataCallbacks = i.metadata || {},
            this.defaults = Object.assign(De(nr), i.defaults || {}),
            this.activeElement = null,
            this.prevActive = null,
            this.silenced = !1,
            this.main = null,
            this.outgoingMainEl = null,
            this.clickStartedAtTarget = null,
            this.linkRef = 1,
            this.roots = {},
            this.href = window.location.href,
            this.pendingLink = null,
            this.currentLocation = De(window.location),
            this.hooks = i.hooks || {},
            this.uploaders = i.uploaders || {},
            this.loaderTimeout = i.loaderTimeout || er,
            this.reloadWithJitterTimer = null,
            this.maxReloads = i.maxReloads || Fi,
            this.reloadJitterMin = i.reloadJitterMin || Bi,
            this.reloadJitterMax = i.reloadJitterMax || Ji,
            this.failsafeJitter = i.failsafeJitter || zi,
            this.localStorage = i.localStorage || window.localStorage,
            this.sessionStorage = i.sessionStorage || window.sessionStorage,
            this.boundTopLevelEvents = !1,
            this.domCallbacks = Object.assign({
                onNodeAdded: Xe(),
                onBeforeElUpdated: Xe()
            }, i.dom || {}),
            this.transitions = new Lr,
            window.addEventListener("pagehide", r => {
                this.unloaded = !0
            }
            ),
            this.socket.onOpen( () => {
                this.isUnloaded() && window.location.reload()
            }
            )
        }
        isProfileEnabled() {
            return this.sessionStorage.getItem(ze) === "true"
        }
        isDebugEnabled() {
            return this.sessionStorage.getItem(Te) === "true"
        }
        isDebugDisabled() {
            return this.sessionStorage.getItem(Te) === "false"
        }
        enableDebug() {
            this.sessionStorage.setItem(Te, "true")
        }
        enableProfiling() {
            this.sessionStorage.setItem(ze, "true")
        }
        disableDebug() {
            this.sessionStorage.setItem(Te, "false")
        }
        disableProfiling() {
            this.sessionStorage.removeItem(ze)
        }
        enableLatencySim(e) {
            this.enableDebug(),
            console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable"),
            this.sessionStorage.setItem(Ve, e)
        }
        disableLatencySim() {
            this.sessionStorage.removeItem(Ve)
        }
        getLatencySim() {
            let e = this.sessionStorage.getItem(Ve);
            return e ? parseInt(e) : null
        }
        getSocket() {
            return this.socket
        }
        connect() {
            window.location.hostname === "localhost" && !this.isDebugDisabled() && this.enableDebug();
            let e = () => {
                this.joinRootViews() ? (this.bindTopLevelEvents(),
                this.socket.connect()) : this.main && this.socket.connect()
            }
            ;
            ["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0 ? e() : document.addEventListener("DOMContentLoaded", () => e())
        }
        disconnect(e) {
            clearTimeout(this.reloadWithJitterTimer),
            this.socket.disconnect(e)
        }
        replaceTransport(e) {
            clearTimeout(this.reloadWithJitterTimer),
            this.socket.replaceTransport(e),
            this.connect()
        }
        execJS(e, t, i=null) {
            this.owner(e, r => $.exec(i, t, r, e))
        }
        triggerDOM(e, t) {
            this.domCallbacks[e](...t)
        }
        time(e, t) {
            if (!this.isProfileEnabled() || !console.time)
                return t();
            console.time(e);
            let i = t();
            return console.timeEnd(e),
            i
        }
        log(e, t, i) {
            if (this.viewLogger) {
                let[r,n] = i();
                this.viewLogger(e, t, r, n)
            } else if (this.isDebugEnabled()) {
                let[r,n] = i();
                lr(e, t, r, n)
            }
        }
        requestDOMUpdate(e) {
            this.transitions.after(e)
        }
        transition(e, t, i=function() {}
        ) {
            this.transitions.addTransition(e, t, i)
        }
        onChannel(e, t, i) {
            e.on(t, r => {
                let n = this.getLatencySim();
                n ? (console.log(`simulating ${n}ms of latency from server to client`),
                setTimeout( () => i(r), n)) : i(r)
            }
            )
        }
        wrapPush(e, t, i) {
            let r = this.getLatencySim()
              , n = e.joinCount;
            if (!r)
                return this.isConnected() && t.timeout ? i().receive("timeout", () => {
                    e.joinCount === n && !e.isDestroyed() && this.reloadWithJitter(e, () => {
                        this.log(e, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"])
                    }
                    )
                }
                ) : i();
            console.log(`simulating ${r}ms of latency from client to server`);
            let s = {
                receives: [],
                receive(o, a) {
                    this.receives.push([o, a])
                }
            };
            return setTimeout( () => {
                e.isDestroyed() || s.receives.reduce( (o, [a,l]) => o.receive(a, l), i())
            }
            , r),
            s
        }
        reloadWithJitter(e, t) {
            clearTimeout(this.reloadWithJitterTimer),
            this.disconnect();
            let i = this.reloadJitterMin
              , r = this.reloadJitterMax
              , n = Math.floor(Math.random() * (r - i + 1)) + i
              , s = K.updateLocal(this.localStorage, window.location.pathname, jt, 0, o => o + 1);
            s > this.maxReloads && (n = this.failsafeJitter),
            this.reloadWithJitterTimer = setTimeout( () => {
                e.isDestroyed() || e.isConnected() || (e.destroy(),
                t ? t() : this.log(e, "join", () => [`encountered ${s} consecutive reloads`]),
                s > this.maxReloads && this.log(e, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]),
                this.hasPendingLink() ? window.location = this.pendingLink : window.location.reload())
            }
            , n)
        }
        getHookCallbacks(e) {
            return e && e.startsWith("Phoenix.") ? fr[e.split(".")[1]] : this.hooks[e]
        }
        isUnloaded() {
            return this.unloaded
        }
        isConnected() {
            return this.socket.isConnected()
        }
        getBindingPrefix() {
            return this.bindingPrefix
        }
        binding(e) {
            return `${this.getBindingPrefix()}${e}`
        }
        channel(e, t) {
            return this.socket.channel(e, t)
        }
        joinRootViews() {
            let e = !1;
            return c.all(document, `${ne}:not([${re}])`, t => {
                if (!this.getRootById(t.id)) {
                    let i = this.newRootView(t);
                    i.setHref(this.getHref()),
                    i.join(),
                    t.hasAttribute(it) && (this.main = i)
                }
                e = !0
            }
            ),
            e
        }
        redirect(e, t) {
            this.disconnect(),
            K.redirect(e, t)
        }
        replaceMain(e, t, i=null, r=this.setPendingLink(e)) {
            this.outgoingMainEl = this.outgoingMainEl || this.main.el;
            let n = c.cloneNode(this.outgoingMainEl, "");
            this.main.showLoader(this.loaderTimeout),
            this.main.destroy(),
            this.main = this.newRootView(n, t),
            this.main.setRedirect(e),
            this.transitionRemoves(),
            this.main.join( (s, o) => {
                s === 1 && this.commitPendingLink(r) && this.requestDOMUpdate( () => {
                    c.findPhxSticky(document).forEach(a => n.appendChild(a)),
                    this.outgoingMainEl.replaceWith(n),
                    this.outgoingMainEl = null,
                    i && requestAnimationFrame(i),
                    o()
                }
                )
            }
            )
        }
        transitionRemoves(e) {
            let t = this.binding("remove");
            e = e || c.all(document, `[${t}]`),
            e.forEach(i => {
                document.body.contains(i) && this.execJS(i, i.getAttribute(t), "remove")
            }
            )
        }
        isPhxView(e) {
            return e.getAttribute && e.getAttribute(Y) !== null
        }
        newRootView(e, t) {
            let i = new zt(e,this,null,t);
            return this.roots[i.id] = i,
            i
        }
        owner(e, t) {
            let i = z(e.closest(ne), r => this.getViewByEl(r)) || this.main;
            i && t(i)
        }
        withinOwners(e, t) {
            this.owner(e, i => t(i, e))
        }
        getViewByEl(e) {
            let t = e.getAttribute(me);
            return z(this.getRootById(t), i => i.getDescendentByEl(e))
        }
        getRootById(e) {
            return this.roots[e]
        }
        destroyAllViews() {
            for (let e in this.roots)
                this.roots[e].destroy(),
                delete this.roots[e];
            this.main = null
        }
        destroyViewByEl(e) {
            let t = this.getRootById(e.getAttribute(me));
            t && t.id === e.id ? (t.destroy(),
            delete this.roots[t.id]) : t && t.destroyDescendent(e.id)
        }
        setActiveElement(e) {
            if (this.activeElement === e)
                return;
            this.activeElement = e;
            let t = () => {
                e === this.activeElement && (this.activeElement = null),
                e.removeEventListener("mouseup", this),
                e.removeEventListener("touchend", this)
            }
            ;
            e.addEventListener("mouseup", t),
            e.addEventListener("touchend", t)
        }
        getActiveElement() {
            return document.activeElement === document.body ? this.activeElement || document.activeElement : document.activeElement || document.body
        }
        dropActiveElement(e) {
            this.prevActive && e.ownsElement(this.prevActive) && (this.prevActive = null)
        }
        restorePreviouslyActiveFocus() {
            this.prevActive && this.prevActive !== document.body && this.prevActive.focus()
        }
        blurActiveElement() {
            this.prevActive = this.getActiveElement(),
            this.prevActive !== document.body && this.prevActive.blur()
        }
        bindTopLevelEvents() {
            this.boundTopLevelEvents || (this.boundTopLevelEvents = !0,
            this.socket.onClose(e => {
                e && e.code === 1e3 && this.main && this.reloadWithJitter(this.main)
            }
            ),
            document.body.addEventListener("click", function() {}),
            window.addEventListener("pageshow", e => {
                e.persisted && (this.getSocket().disconnect(),
                this.withPageLoading({
                    to: window.location.href,
                    kind: "redirect"
                }),
                window.location.reload())
            }
            , !0),
            this.bindNav(),
            this.bindClicks(),
            this.bindForms(),
            this.bind({
                keyup: "keyup",
                keydown: "keydown"
            }, (e, t, i, r, n, s) => {
                let o = r.getAttribute(this.binding(Qi))
                  , a = e.key && e.key.toLowerCase();
                if (o && o.toLowerCase() !== a)
                    return;
                let l = se({
                    key: e.key
                }, this.eventMeta(t, e, r));
                $.exec(t, n, i, r, ["push", {
                    data: l
                }])
            }
            ),
            this.bind({
                blur: "focusout",
                focus: "focusin"
            }, (e, t, i, r, n, s) => {
                if (!s) {
                    let o = se({
                        key: e.key
                    }, this.eventMeta(t, e, r));
                    $.exec(t, n, i, r, ["push", {
                        data: o
                    }])
                }
            }
            ),
            this.bind({
                blur: "blur",
                focus: "focus"
            }, (e, t, i, r, n, s, o) => {
                if (o === "window") {
                    let a = this.eventMeta(t, e, r);
                    $.exec(t, s, i, r, ["push", {
                        data: a
                    }])
                }
            }
            ),
            window.addEventListener("dragover", e => e.preventDefault()),
            window.addEventListener("drop", e => {
                e.preventDefault();
                let t = z(ge(e.target, this.binding(vt)), n => n.getAttribute(this.binding(vt)))
                  , i = t && document.getElementById(t)
                  , r = Array.from(e.dataTransfer.files || []);
                !i || i.disabled || r.length === 0 || !(i.files instanceof FileList) || (T.trackFiles(i, r),
                i.dispatchEvent(new Event("input",{
                    bubbles: !0
                })))
            }
            ),
            this.on(Ut, e => {
                let t = e.target;
                if (!c.isUploadInput(t))
                    return;
                let i = Array.from(e.detail.files || []).filter(r => r instanceof File || r instanceof Blob);
                T.trackFiles(t, i),
                t.dispatchEvent(new Event("input",{
                    bubbles: !0
                }))
            }
            ))
        }
        eventMeta(e, t, i) {
            let r = this.metadataCallbacks[e];
            return r ? r(t, i) : {}
        }
        setPendingLink(e) {
            return this.linkRef++,
            this.pendingLink = e,
            this.linkRef
        }
        commitPendingLink(e) {
            return this.linkRef !== e ? !1 : (this.href = this.pendingLink,
            this.pendingLink = null,
            !0)
        }
        getHref() {
            return this.href
        }
        hasPendingLink() {
            return !!this.pendingLink
        }
        bind(e, t) {
            for (let i in e) {
                let r = e[i];
                this.on(r, n => {
                    let s = this.binding(i)
                      , o = this.binding(`window-${i}`)
                      , a = n.target.getAttribute && n.target.getAttribute(s);
                    a ? this.debounce(n.target, n, r, () => {
                        this.withinOwners(n.target, l => {
                            t(n, i, l, n.target, a, null)
                        }
                        )
                    }
                    ) : c.all(document, `[${o}]`, l => {
                        let d = l.getAttribute(o);
                        this.debounce(l, n, r, () => {
                            this.withinOwners(l, f => {
                                t(n, i, f, l, d, "window")
                            }
                            )
                        }
                        )
                    }
                    )
                }
                )
            }
        }
        bindClicks() {
            window.addEventListener("mousedown", e => this.clickStartedAtTarget = e.target),
            this.bindClick("click", "click", !1),
            this.bindClick("mousedown", "capture-click", !0)
        }
        bindClick(e, t, i) {
            let r = this.binding(t);
            window.addEventListener(e, n => {
                let s = null;
                if (i)
                    s = n.target.matches(`[${r}]`) ? n.target : n.target.querySelector(`[${r}]`);
                else {
                    let a = this.clickStartedAtTarget || n.target;
                    s = ge(a, r),
                    this.dispatchClickAway(n, a),
                    this.clickStartedAtTarget = null
                }
                let o = s && s.getAttribute(r);
                o && (s.getAttribute("href") === "#" && n.preventDefault(),
                this.debounce(s, n, "click", () => {
                    this.withinOwners(s, a => {
                        $.exec("click", o, a, s, ["push", {
                            data: this.eventMeta("click", n, s)
                        }])
                    }
                    )
                }
                ))
            }
            , i)
        }
        dispatchClickAway(e, t) {
            let i = this.binding("click-away");
            c.all(document, `[${i}]`, r => {
                r.isSameNode(t) || r.contains(t) || this.withinOwners(e.target, n => {
                    let s = r.getAttribute(i);
                    $.isVisible(r) && $.exec("click", s, n, r, ["push", {
                        data: this.eventMeta("click", e, e.target)
                    }])
                }
                )
            }
            )
        }
        bindNav() {
            if (!K.canPushState())
                return;
            history.scrollRestoration && (history.scrollRestoration = "manual");
            let e = null;
            window.addEventListener("scroll", t => {
                clearTimeout(e),
                e = setTimeout( () => {
                    K.updateCurrentState(i => Object.assign(i, {
                        scroll: window.scrollY
                    }))
                }
                , 100)
            }
            ),
            window.addEventListener("popstate", t => {
                if (!this.registerNewLocation(window.location))
                    return;
                let {type: i, id: r, root: n, scroll: s} = t.state || {}
                  , o = window.location.href;
                this.requestDOMUpdate( () => {
                    this.main.isConnected() && i === "patch" && r === this.main.id ? this.main.pushLinkPatch(o, null) : this.replaceMain(o, null, () => {
                        n && this.replaceRootHistory(),
                        typeof s == "number" && setTimeout( () => {
                            window.scrollTo(0, s)
                        }
                        , 0)
                    }
                    )
                }
                )
            }
            , !1),
            window.addEventListener("click", t => {
                let i = ge(t.target, Fe)
                  , r = i && i.getAttribute(Fe)
                  , n = t.metaKey || t.ctrlKey || t.button === 1;
                if (!r || !this.isConnected() || !this.main || n)
                    return;
                let s = i.href
                  , o = i.getAttribute(Xi);
                t.preventDefault(),
                t.stopImmediatePropagation(),
                this.pendingLink !== s && this.requestDOMUpdate( () => {
                    if (r === "patch")
                        this.pushHistoryPatch(s, o, i);
                    else if (r === "redirect")
                        this.historyRedirect(s, o);
                    else
                        throw new Error(`expected ${Fe} to be "patch" or "redirect", got: ${r}`)
                }
                )
            }
            , !1)
        }
        dispatchEvent(e, t={}) {
            c.dispatchEvent(window, `phx:${e}`, {
                detail: t
            })
        }
        dispatchEvents(e) {
            e.forEach( ([t,i]) => this.dispatchEvent(t, i))
        }
        withPageLoading(e, t) {
            c.dispatchEvent(window, "phx:page-loading-start", {
                detail: e
            });
            let i = () => c.dispatchEvent(window, "phx:page-loading-stop", {
                detail: e
            });
            return t ? t(i) : i
        }
        pushHistoryPatch(e, t, i) {
            this.withPageLoading({
                to: e,
                kind: "patch"
            }, r => {
                this.main.pushLinkPatch(e, i, n => {
                    this.historyPatch(e, t, n),
                    r()
                }
                )
            }
            )
        }
        historyPatch(e, t, i=this.setPendingLink(e)) {
            this.commitPendingLink(i) && (K.pushState(t, {
                type: "patch",
                id: this.main.id
            }, e),
            this.registerNewLocation(window.location))
        }
        historyRedirect(e, t, i) {
            let r = window.scrollY;
            this.withPageLoading({
                to: e,
                kind: "redirect"
            }, n => {
                this.replaceMain(e, i, () => {
                    K.pushState(t, {
                        type: "redirect",
                        id: this.main.id,
                        scroll: r
                    }, e),
                    this.registerNewLocation(window.location),
                    n()
                }
                )
            }
            )
        }
        replaceRootHistory() {
            K.pushState("replace", {
                root: !0,
                type: "patch",
                id: this.main.id
            })
        }
        registerNewLocation(e) {
            let {pathname: t, search: i} = this.currentLocation;
            return t + i === e.pathname + e.search ? !1 : (this.currentLocation = De(e),
            !0)
        }
        bindForms() {
            let e = 0;
            this.on("submit", t => {
                let i = t.target.getAttribute(this.binding("submit"));
                i && (t.preventDefault(),
                t.target.disabled = !0,
                this.withinOwners(t.target, r => {
                    $.exec("submit", i, r, t.target, ["push", {}])
                }
                ))
            }
            , !1);
            for (let t of ["change", "input"])
                this.on(t, i => {
                    let r = this.binding("change")
                      , n = i.target
                      , s = n.getAttribute(r)
                      , o = n.form && n.form.getAttribute(r)
                      , a = s || o;
                    if (!a || n.type === "number" && n.validity && n.validity.badInput)
                        return;
                    let l = s ? n : n.form
                      , d = e;
                    e++;
                    let {at: f, type: h} = c.private(n, "prev-iteration") || {};
                    f === d - 1 && t !== h || (c.putPrivate(n, "prev-iteration", {
                        at: d,
                        type: t
                    }),
                    this.debounce(n, i, t, () => {
                        this.withinOwners(l, p => {
                            c.putPrivate(n, $t, !0),
                            c.isTextualInput(n) || this.setActiveElement(n),
                            $.exec("change", a, p, n, ["push", {
                                _target: i.target.name,
                                dispatcher: l
                            }])
                        }
                        )
                    }
                    ))
                }
                , !1)
        }
        debounce(e, t, i, r) {
            if (i === "blur" || i === "focusout")
                return r();
            let n = this.binding(Gi)
              , s = this.binding(Yi)
              , o = this.defaults.debounce.toString()
              , a = this.defaults.throttle.toString();
            this.withinOwners(e, l => {
                let d = () => !l.isDestroyed() && document.body.contains(e);
                c.debounce(e, t, n, o, s, a, d, () => {
                    r()
                }
                )
            }
            )
        }
        silenceEvents(e) {
            this.silenced = !0,
            e(),
            this.silenced = !1
        }
        on(e, t) {
            window.addEventListener(e, i => {
                this.silenced || t(i)
            }
            )
        }
    }
      , Lr = class {
        constructor() {
            this.transitions = new Set,
            this.pendingOps = [],
            this.reset()
        }
        reset() {
            this.transitions.forEach(e => {
                cancelTimeout(e),
                this.transitions.delete(e)
            }
            ),
            this.flushPendingOps()
        }
        after(e) {
            this.size() === 0 ? e() : this.pushPendingOp(e)
        }
        addTransition(e, t, i) {
            t();
            let r = setTimeout( () => {
                this.transitions.delete(r),
                i(),
                this.size() === 0 && this.flushPendingOps()
            }
            , e);
            this.transitions.add(r)
        }
        pushPendingOp(e) {
            this.pendingOps.push(e)
        }
        size() {
            return this.transitions.size
        }
        flushPendingOps() {
            this.pendingOps.forEach(e => e()),
            this.pendingOps = []
        }
    }
    ;
    var Ai = ut(xi())
      , kn = document.querySelector("meta[name='csrf-token']").getAttribute("content")
      , Ei = {
        mounted() {
            let e = this.el.getAttribute("phx-hook-event") || "submit"
              , t = this.el.getAttribute("phx-debounce") || 0
              , i = this.el.form || this.el
              , r = (0,
            Ai.default)( () => {
                if (this.el.form != null && this.el.value === "")
                    return;
                let n = new URLSearchParams;
                for (let o = 0; o < i.length; o++) {
                    let a = i[o];
                    a.name != null && a.name !== "" && n.set(a.name, a.value)
                }
                let s = {
                    method: "POST",
                    mode: "cors",
                    cache: "no-cache",
                    credentials: "same-origin",
                    headers: {
                        "Content-type": "application/x-www-form-urlencoded",
                        "x-csrf-token": kn
                    },
                    body: n
                };
                window.fetch(i.action, s).then(o => {
                    o.ok || (console.error("Bad request made to server"),
                    window.reload())
                }
                ).catch(o => {
                    console.error(o),
                    window.reload()
                }
                )
            }
            , t);
            e.split(" ").forEach(n => {
                this.el.addEventListener(n, s => {
                    n === "submit" && s.preventDefault(),
                    r()
                }
                )
            }
            ),
            this.handleEvent("persist", () => r())
        }
    };
    var Sn = document.querySelector("meta[name='stripe-key']").getAttribute("content")
      , Ci = {
        mounted() {
            this.handleEvent("sessionRedirect", e => window.Stripe(Sn).redirectToCheckout({
                sessionId: e.session_id
            }))
        }
    };
    var xn = document.querySelector("meta[name='csrf-token']").getAttribute("content")
      , Ti = new Vt("/live",pt,{
        params: {
            _csrf_token: xn
        },
        hooks: {
            SetSession: Ei,
            Stripe: Ci
        }
    });
    Oe.default.config({
        barColors: {
            0: "#29d"
        },
        shadowColor: "rgba(0, 0, 0, .3)"
    });
    window.addEventListener("phx:page-loading-start", e => Oe.default.show());
    window.addEventListener("phx:page-loading-stop", e => Oe.default.hide());
    Ti.connect();
    window.liveSocket = Ti;
}
)();
/*! Bundled license information:

topbar/topbar.min.js:
  (**
   * @license MIT
   * topbar 2.0.0, 2023-02-04
   * http://buunguyen.github.io/topbar
   * Copyright (c) 2021 Buu Nguyen
   *)
*/
